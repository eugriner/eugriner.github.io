= COMPUTAÇÃO GRÁFICA 2015.2
:source-highlighter: prettify
:sectnums:
:sourcedir: ex/
:toc: right
:linkattrs:
Discente
Hanoch Griner <eugriner@gmail.com>

Esse relatório contém a resolução dos exercícios referentes ao tutorial de OpenGL do docente Agostinho Brito.
http://agostinhobritojr.github.io/tutoriais/opengl/

O relatório esta dividido em tópicos seguindo a estrutura do tutorial. Cada tópico contém: questão, seguida do código fonte desenvolvido/adaptado para resolver a questão e por último a imagem ou imagens geradas na execução do código.

Para compilar e executar qualquer arquivo desse relatório deve-se colocar o arquivo Makefile na mesma pasta do arquivo .c desejado e executar o seguinte comando:

----
$ make arquivodesejado && ./arquivodesejado
----

Exemplo

.Arquivos:

* link:ex/Makefile[Makefile, window="_blank"] 
* link:ex/teste.c[teste.c, window="_blank"] 

.Comando:
----
$ make teste && ./teste
----

Lembre-se que você precisa ter o GLUT e um compilador C/C++ no seu computador, caso não de certo, siga as instruções do link:http://agostinhobritojr.github.io/tutoriais/opengl/conceitos-iniciais.html#compilando-programas[tutorial do professor, window="_blank"].

== Conceitos iniciais

=== Quadrados 4

==== Questão

Utilizando o programa teste-make.c como referência, implemente um programa quadrados4.c. Este programa deverá desenhar numa janela com fundo branco, de dimensões 256x256 pixels, e quatro quadrados de cores diferentes arranjados na janela.

.Arquivos:
* link:ex/1/teste-make.c[teste-make.c, window="_blank"]
* link:ex/1/quadrados4.c[quadrados4.c, window="_blank"]

==== Código

[source,c++]
----
include::{sourcedir}/1/quadrados4.c[]
----

==== Imagem

image::ex/1/quadrados4.png[]

=== Quadrados Color

==== Questão

Utilizando o programa teste-make.c como referência, implemente um programa quadradoscolor.c. Este programa deverá desenhar numa janela com fundo branco, de dimensões 256x256 pixels, um quadrado com as mesmas dimensões do quadrado original. Entretanto, cada uma das cores determinadas para os quatro vértices do quadrado deverão ser determinadas a partir de valores calculados via modelo HSI. Implemente um temporizador para os valores de H mudarem com o tempo para os vértices, produzindo uma pequena animação. Comente a linha glShadeModel(GL_FLAT) para que o feito de degradê possa ser visualizado.

.Arquivos:
* link:ex/1/teste-make.c[teste-make.c , window="_blank"]
* link:ex/1/quadradosColor.c[quadradosColor.c, window="_blank"]

==== Código

[source,c++]
----
include::{sourcedir}/1/quadradosColor.c[]
----

==== Imagem

image::ex/1/quadradosColor1.png[]

image::ex/1/quadradosColor2.png[]

== Desenhando linhas e pontos

=== Quadrado

==== Questão

Utilizando o programa linha.c como referência, implemente um programa quadrado.c. Este programa deverá desenhar numa janela com fundo branco, de dimensões 256x256 pixels, um quadrado vermelho, com vértice superior esquerdo de coordenadas (x, y)= (30, 226) e vértice inferior direito de coordenadas (x, y) = (226, 30). Quando a tecla a (keycode=97) for pressionada, o quadrado deverá ficar com a cor azul. Quando a tecla v (keycode=118) for pressionada, o quadrado deverá voltar à cor vermelha.

.Arquivos:
* link:ex/2/linha.c[linha.c , window="_blank"]
* link:ex/2/quadrado.c[quadrado.c, window="_blank"]

==== Código

[source,c++]
----
include::{sourcedir}/2/quadrado.c[]
----

==== Imagem

image::ex/2/quadrado1.png[]

image::ex/2/quadrado2.png[]

=== Bresenham Linha

==== Questão

Implemente o algoritmo de Bresenham para traçado de linhas, utilizando GL_POINTS como parâmetro da função glBegin(). Este parâmetro indica que cada vértice deve ser tratado como um ponto simples. Utilizando o algoritmo implementado, desenhe uma reta verde do ponto (x, y)=(40, 200) ao ponto (x, y)=(200, 10).

.Arquivos:
* link:ex/2/bresenhamLinha.c[bresenhamLinha.c, window="_blank"]

==== Código

[source,c++]
----
include::{sourcedir}/2/bresenhamLinha.c[]
----

==== Imagem

image::ex/2/bresenhamLinha.png[]

=== Bresenham Círculo

==== Questão

Implemente o algoritmo de Bresenham para traçado de circunferências, utilizando GL_POINTS como parâmetro da função glBegin(). Utilizando o algoritmo implementado, desenhe uma circunferência azul de raio r=50, centrada no ponto (x, y) = (128, 128).

.Arquivos:
* link:ex/2/bresenhamCircle.c[bresenhamCircle.c, window="_blank"]

==== Código

[source,c++]
----
include::{sourcedir}/2/bresenhamCircle.c[]
----

==== Imagem

image::ex/2/bresenhamCircle.png[]

== Preenchimento de regiões

=== Seleção

==== Questão

Utilizando o programa preenchimento.c como referência, implemente um programa selecao.c. Este programa deverá desenhar numa janela com fundo branco, de dimensões 256x256 pixels, quatro polígonos com as mesmas coordenadas dos polígonos do programa de referência. Todos os polígonos devem estar inicialmente preenchidos de amarelo e com bordas pretas. Quando o usuário clicar com o botão esquerdo do mouse dentro de um dos polígonos, a cor de preechimento deste polígono deverá mudar para uma cor aleatória. Quando a tecla b (keycode=98) for pressionada, o programa passará a mudar as cores das bordas e não mais dos fundos dos polígonos. Quando a tecla f (keycode=102) for pressionada, o programa passará a mudar as cores dos fundos dos polígonos e não mais das bordas.

.Arquivos:
* link:ex/3/preenchimento.c[preenchimento.c, window="_blank"]
* link:ex/3/selecao.c[selecao.c, window="_blank"]

==== Código

[source,c++]
----
include::{sourcedir}/3/selecao.c[]
----

==== Imagem

image::ex/3/selecao1.png[]

image::ex/3/selecao2.png[]

=== Seleção Buffer Simples

==== Questão

Repita o item anterior utilizando buffer simples e comente os resultados obtidos.

.Arquivos:
* link:ex/3/selecaoBS.c[selecaoBS.c, window="_blank"]

==== Código

[source,c++]
----
include::{sourcedir}/3/selecaoBS.c[]
----

==== Imagem

image::ex/3/selecaoBS.png[]

==== Comentário
Meus olhos destreinados não foram capazes de notar nenhuma alteração após alterar de DOUBLE para SINGLE e desabilitar o swap.

=== Padrão HG

==== Questão

Crie um padrão de preenchimento com as iniciais dos seu nome e sobre nome, por exemplo, AB, para Agostinho Brito. Implemente um programa que desenhe em uma janela de fundo branco de dimensões 300x300 pixels um hexágono com bounding box de dimensões 200x200 pixels. O hexágono deve estar centrado na tela e preenchido com cor azul, utilize este padrão de preenchimento criado.

.Arquivos:
* link:ex/3/padrao.c[padrao.c, window="_blank"]

==== Código

[source,c++]
----
include::{sourcedir}/3/padrao.c[]
----

==== Imagem

image::ex/3/padrao.png[]



== Transformações Geométricas

=== Braço Garra

==== Questão

Utilizando o programa braco.c como referência, implemente um programa braco-garra.c. Este programa deverá acrescente ao braço robótico uma garra com três dedos, sendo um indicador, um médio e um polegar, como mostra a Figura 4.3. O usuário deverá poder rotacionar o dedo indicador com as teclas i e I, nos sentidos horário e anti-horário. Da mesma forma, as teclas p P deverão rotacionar o polegar, e teclas m M, o dedo médio do robô.

image::ex/4/Figura4.3.png[]


.Arquivos:
* link:ex/4/braco.c[braco.c, window="_blank"]
* link:ex/4/braco-garra.c[braco-garra.c, window="_blank"]

==== Código

[source,c++]
----
include::{sourcedir}/4/braco-garra.c[]
----

==== Imagem

image::ex/4/braco-garra1.png[]

image::ex/4/braco-garra2.png[]

=== Braço Garra 3D

==== Questão

Copie o programa braco-garra.c que você criou com o nome braco-garra-3d.c. Neste novo programa, modifique o trecho da função main() que define o modo de apresentação no GLUT. Use a seguinte chamada para a função de inicialização: glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH), pois inclui o tratamento de profundidade e de superfícies escondidas no OpenGL . Além disso, ao invés de utilizar chamadas à função glutWireCube(), inclua chamadas apenas à função glutSolidCube(), que contém os mesmos argumentos. Acrescente à função init() as chamadas de função glEnable(GL_DEPTH_TEST); e glEnable(GL_CULL_FACE);, de modo que o tratamento de superfícies escondidas seja feito pelo OpenGL. Utilize cores diferentes para cada uma das partes do braço, de modo a obter um modelo semelhante ao da Figura 4.4. Possibilite também que a base do robô seja rotacionada em torno do eixo y, usando as teclas b e B, para girar nos sentidos horário e anti-horário.

image::ex/4/Figura4.4.png[]


.Arquivos:
* link:ex/4/braco.c[braco-garra.c, window="_blank"]
* link:ex/4/braco-garra.c[braco-garra-3d.c, window="_blank"]

==== Código

[source,c++]
----
include::{sourcedir}/4/braco-garra-3d.c[]
----

==== Imagem

image::ex/4/braco-garra-3d1.png[]

image::ex/4/braco-garra-3d3.png[]
