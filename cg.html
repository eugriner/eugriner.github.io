<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.2">
<meta name="author" content="Discente">
<title>COMPUTAÇÃO GRÁFICA 2015.2</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove the comments around the @import statement below when using this as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
body{margin:0}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
#map_canvas img,#map_canvas embed,#map_canvas object,.map_canvas img,.map_canvas embed,.map_canvas object{max-width:none!important}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
.antialiased,body{-webkit-font-smoothing:antialiased}
img{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol,ul.no-bullet,ol.no-bullet{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.no-bullet{list-style:none}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
.keyseq{color:rgba(51,51,51,.8)}
kbd{display:inline-block;color:rgba(0,0,0,.8);font-size:.75em;line-height:1.4;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:-.15em .15em 0 .15em;padding:.2em .6em .2em .5em;vertical-align:middle;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menu{color:rgba(0,0,0,.8)}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.05em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.spread{width:100%}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all th.tableblock,table.grid-all td.tableblock{border-width:0 1px 1px 0}
table.grid-all tfoot>tr>th.tableblock,table.grid-all tfoot>tr>td.tableblock{border-width:1px 1px 0 0}
table.grid-cols th.tableblock,table.grid-cols td.tableblock{border-width:0 1px 0 0}
table.grid-all *>tr>.tableblock:last-child,table.grid-cols *>tr>.tableblock:last-child{border-right-width:0}
table.grid-rows th.tableblock,table.grid-rows td.tableblock{border-width:0 0 1px 0}
table.grid-all tbody>tr:last-child>th.tableblock,table.grid-all tbody>tr:last-child>td.tableblock,table.grid-all thead:last-child>tr>th.tableblock,table.grid-rows tbody>tr:last-child>th.tableblock,table.grid-rows tbody>tr:last-child>td.tableblock,table.grid-rows thead:last-child>tr>th.tableblock{border-bottom-width:0}
table.grid-rows tfoot>tr>th.tableblock,table.grid-rows tfoot>tr>td.tableblock{border-width:1px 0 0 0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.unstyled,ol.unnumbered,ul.checklist,ul.none{list-style-type:none}
ul.unstyled,ol.unnumbered,ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1em;font-size:.85em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{width:1em;position:relative;top:1px}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1{padding-right:.75em;font-weight:bold}
td.hdlist1,td.hdlist2{vertical-align:top}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:0 .75em;line-height:1}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none}
span.footnote,span.footnoteref{vertical-align:super;font-size:.875em}
span.footnote a,span.footnoteref a{text-decoration:none}
span.footnote a:active,span.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em;line-height:1.3;font-size:.875em;margin-left:1.2em;text-indent:-1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
h1,h2{letter-spacing:-.01em}
dt,th.tableblock,td.content{text-rendering:optimizeLegibility}
p,td.content{letter-spacing:-.01em}
p strong,td.content strong{letter-spacing:-.005em}
p,blockquote,dt,td.content{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img{page-break-inside:avoid}
thead{display:table-header-group}
img{max-width:100%!important}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>document.addEventListener('DOMContentLoaded', prettyPrint)</script>
</head>
<body class="article toc2 toc-right">
<div id="header">
<h1>COMPUTAÇÃO GRÁFICA 2015.2</h1>
<div class="details">
<span id="author" class="author">Discente</span><br>
<span id="revdate">Hanoch Griner &lt;eugriner@gmail.com&gt;</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_conceitos_iniciais">1. Conceitos iniciais</a>
<ul class="sectlevel2">
<li><a href="#_quadrados_4">1.1. Quadrados 4</a></li>
<li><a href="#_quadrados_color">1.2. Quadrados Color</a></li>
</ul>
</li>
<li><a href="#_desenhando_linhas_e_pontos">2. Desenhando linhas e pontos</a>
<ul class="sectlevel2">
<li><a href="#_quadrado">2.1. Quadrado</a></li>
<li><a href="#_bresenham_linha">2.2. Bresenham Linha</a></li>
<li><a href="#_bresenham_círculo">2.3. Bresenham Círculo</a></li>
</ul>
</li>
<li><a href="#_preenchimento_de_regiões">3. Preenchimento de regiões</a>
<ul class="sectlevel2">
<li><a href="#_seleção">3.1. Seleção</a></li>
<li><a href="#_seleção_buffer_simples">3.2. Seleção Buffer Simples</a></li>
<li><a href="#_padrão_hg">3.3. Padrão HG</a></li>
</ul>
</li>
<li><a href="#_transformações_geométricas">4. Transformações Geométricas</a>
<ul class="sectlevel2">
<li><a href="#_braço_garra">4.1. Braço Garra</a></li>
<li><a href="#_braço_garra_3d">4.2. Braço Garra 3D</a></li>
</ul>
</li>
<li><a href="#_projeções_geométricas">5. Projeções geométricas</a>
<ul class="sectlevel2">
<li><a href="#_tipos_de_projeções">5.1. Tipos de Projeções</a></li>
<li><a href="#_projeções_animadas">5.2. Projeções Animadas</a></li>
</ul>
</li>
<li><a href="#_curvas_no_plano">6. Curvas no plano</a>
<ul class="sectlevel2">
<li><a href="#_funcionalidades">6.1. Funcionalidades</a></li>
<li><a href="#_splines_nurbs">6.2. Splines Nurbs</a></li>
<li><a href="#_ordem_splines_nurbs">6.3. Ordem Splines Nurbs</a></li>
<li><a href="#_comparação">6.4. Comparação</a></li>
</ul>
</li>
<li><a href="#_superfícies_no_espaço">7. Superfícies no espaço</a>
<ul class="sectlevel2">
<li><a href="#_spline_inter">7.1. Spline Inter</a></li>
</ul>
</li>
<li><a href="#_modelagem_de_sólidos">8. Modelagem de Sólidos</a>
<ul class="sectlevel2">
<li><a href="#_super_jato">8.1. Super Jato</a></li>
<li><a href="#_super_jato_com_logo">8.2. Super Jato com Logo</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Esse relatório contém a resolução dos exercícios referentes ao tutorial de OpenGL do docente Agostinho Brito.
<a href="http://agostinhobritojr.github.io/tutoriais/opengl/" class="bare">http://agostinhobritojr.github.io/tutoriais/opengl/</a></p>
</div>
<div class="paragraph">
<p>O relatório esta dividido em tópicos seguindo a estrutura do tutorial. Cada tópico contém: questão, seguida do código fonte desenvolvido/adaptado para resolver a questão e por último a imagem ou imagens geradas na execução do código.</p>
</div>
<div class="paragraph">
<p>Para compilar e executar qualquer arquivo desse relatório deve-se colocar o arquivo Makefile na mesma pasta do arquivo .c desejado e executar o seguinte comando:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ make arquivodesejado &amp;&amp; ./arquivodesejado</pre>
</div>
</div>
<div class="paragraph">
<p>Exemplo</p>
</div>
<div class="ulist">
<div class="title">Arquivos:</div>
<ul>
<li>
<p><a href="ex/Makefile" target="_blank">Makefile</a></p>
</li>
<li>
<p><a href="ex/teste.c" target="_blank">teste.c</a></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Comando:</div>
<div class="content">
<pre>$ make teste &amp;&amp; ./teste</pre>
</div>
</div>
<div class="paragraph">
<p>Lembre-se que você precisa ter o GLUT e um compilador C/C++ no seu computador, caso não de certo, siga as instruções do <a href="http://agostinhobritojr.github.io/tutoriais/opengl/conceitos-iniciais.html#compilando-programas" target="_blank">tutorial do professor</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conceitos_iniciais">1. Conceitos iniciais</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_quadrados_4">1.1. Quadrados 4</h3>
<div class="sect3">
<h4 id="_questão">1.1.1. Questão</h4>
<div class="paragraph">
<p>Utilizando o programa teste-make.c como referência, implemente um programa quadrados4.c. Este programa deverá desenhar numa janela com fundo branco, de dimensões 256x256 pixels, e quatro quadrados de cores diferentes arranjados na janela.</p>
</div>
<div class="ulist">
<div class="title">Arquivos:</div>
<ul>
<li>
<p><a href="ex/1/teste-make.c" target="_blank">teste-make.c</a></p>
</li>
<li>
<p><a href="ex/1/quadrados4.c" target="_blank">quadrados4.c</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_código">1.1.2. Código</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

void display(void);
void timer(int);
void keyboard(unsigned char key, int x, int y);

/* cores do quadrado */
GLfloat r=1.0, g=0.5, b=0.0;

int main(int argc, char** argv){
  glutInit(&amp;argc, argv);
  glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB);
  glutInitWindowSize (256, 256);
  glutInitWindowPosition (100, 100);
  glutCreateWindow (argv[0]);
  // inicia um temporizador. após 33ms ativa a funcao timer
  glutTimerFunc(33, timer, 1);
  glClearColor(1.0, 1.0, 1.0, 0.0);
  //glShadeModel (GL_FLAT);
  glOrtho (0, 1, 0, 1, -1 ,1);
  glutDisplayFunc(display);
  glutMainLoop();
  return 0;
}

void timer(int value){
  r=r+0.01;
  g=g+0.01;
  b=b+0.01;
  if(r&gt;1) r=0;
  if(g&gt;1) g=0;
  if(b&gt;1) b=0;
  glutPostRedisplay();
  glutTimerFunc(33, timer, 1);
}

void display(void){
  int i;
  glClear(GL_COLOR_BUFFER_BIT);

  // quadrado 1
  glBegin(GL_POLYGON);
  glColor3f (1.0, 0.0, 0.0);
  glVertex2f(0.25,0.25);
  glVertex2f(0.45,0.25);
  glVertex2f(0.45,0.45);
  glVertex2f(0.25,0.45);
  glEnd();
  // quadrado 2
  glBegin(GL_POLYGON);
  glColor3f (1.0, 1.0, 0.0);
  glVertex2f(0.25,0.55);
  glVertex2f(0.25,0.75);
  glVertex2f(0.45,0.75);
  glVertex2f(0.45,0.55);
  glEnd();
  //quadrado 3
  glBegin(GL_POLYGON);
  glColor3f (0.0, 1.0, 0.0);
  glVertex2f(0.55,0.55);
  glVertex2f(0.75,0.55);
  glVertex2f(0.75,0.75);
  glVertex2f(0.55,0.75);
  glEnd();
  //quadrado 4
  glBegin(GL_POLYGON);
  glColor3f (0.0, 1.0, 1.0);
  glVertex2f(0.55,0.25);
  glVertex2f(0.75,0.25);
  glVertex2f(0.75,0.45);
  glVertex2f(0.55,0.45);
  glEnd();
  glFlush();
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_imagem">1.1.3. Imagem</h4>
<div class="imageblock">
<div class="content">
<img src="ex/1/quadrados4.png" alt="quadrados4">
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_quadrados_color">1.2. Quadrados Color</h3>
<div class="sect3">
<h4 id="_questão_2">1.2.1. Questão</h4>
<div class="paragraph">
<p>Utilizando o programa teste-make.c como referência, implemente um programa quadradoscolor.c. Este programa deverá desenhar numa janela com fundo branco, de dimensões 256x256 pixels, um quadrado com as mesmas dimensões do quadrado original. Entretanto, cada uma das cores determinadas para os quatro vértices do quadrado deverão ser determinadas a partir de valores calculados via modelo HSI. Implemente um temporizador para os valores de H mudarem com o tempo para os vértices, produzindo uma pequena animação. Comente a linha glShadeModel(GL_FLAT) para que o feito de degradê possa ser visualizado.</p>
</div>
<div class="ulist">
<div class="title">Arquivos:</div>
<ul>
<li>
<p><a href="ex/1/teste-make.c" target="_blank">teste-make.c</a></p>
</li>
<li>
<p><a href="ex/1/quadradosColor.c" target="_blank">quadradosColor.c</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_código_2">1.2.2. Código</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;cmath&gt;

void display(void);
void timer(int);
void keyboard(unsigned char key, int x, int y);
void HSItoRGB(int h, float s, float i);
float rad(float a);

/* cores do quadrado */
GLfloat r=0.0, g=0.0, b=0.0;
float s, i;
int h;

int main(int argc, char** argv){
  h = 0;
  s = 1.0;
  i = 0.5;

  glutInit(&amp;argc, argv);
  glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB);
  glutInitWindowSize (256, 256);
  glutInitWindowPosition (100, 100);
  glutCreateWindow (argv[0]);
  // inicia um temporizador. após 33ms ativa a funcao timer
  glutTimerFunc(33, timer, 1);
  glClearColor(1.0, 1.0, 1.0, 0.0);
  //glShadeModel (GL_FLAT);
  glOrtho (0, 1, 0, 1, -1 ,1);
  glutDisplayFunc(display);
  glutMainLoop();
  return 0;
}

void timer(int value){
  h = h + 1;
  printf("h=%d\n", h);
  if(h&gt;90) h=0;
  glutPostRedisplay();
  glutTimerFunc(100, timer, 1);
}

void display(void){
  glClear(GL_COLOR_BUFFER_BIT);
  glBegin(GL_POLYGON);

  //v1
  //
  //.
  HSItoRGB(h, s, i);
  glColor3f (r, g, b);
  printf("(%f,%f,%f)\n",r,g,b );
  glVertex2f(0.25,0.25);

  //v2
  //
  //.  .
  HSItoRGB(h+180, s, i);
  glColor3f (r, g, b);
  printf("(%f,%f,%f)\n",r,g,b );
  glVertex2f(0.75,0.25);

  //v3
  //   .
  //.  .
  HSItoRGB(h+90, s, i);
  glColor3f (r, g, b);
  printf("(%f,%f,%f)\n",r,g,b );
  glVertex2f(0.75,0.75);

  //v4
  //.  .
  //.  .
  HSItoRGB(h+270, s, i);
  glColor3f (r, g, b);
  printf("(%f,%f,%f)\n",r,g,b );
  glVertex2f(0.25,0.75);
  glEnd();
  glFlush();
}

void HSItoRGB(int h, float s, float i) {
  if (h&gt;= 0 &amp;&amp; h &lt; 120)
  {
    b = i*(1-s)/3;
    r = i*(1+(s*cos(rad(h))/cos(rad(60-h))))/3;
    g = i*(1-(r+b));
  } else if (h &lt; 240)
  {
    h = h-120;
    r = i*(1-s)/3;
    g = i*(1+(s*cos(rad(h))/cos(rad(60-h))))/3;
    b = i*(1-(r+g));
  } else if (h &lt;= 360)
  {
    h = h-240;
    g = i*(1-s)/3;
    b = i*(1+(s*cos(rad(h))/cos(rad(60-h))))/3;
    r = i*(1-(g+b));
  } else {
    printf("\nERROR - Invalid Color!!\n");
  }
}
float rad(float a) {
  return a*M_PI/180.0;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_imagem_2">1.2.3. Imagem</h4>
<div class="imageblock">
<div class="content">
<img src="ex/1/quadradosColor1.png" alt="quadradosColor1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="ex/1/quadradosColor2.png" alt="quadradosColor2">
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_desenhando_linhas_e_pontos">2. Desenhando linhas e pontos</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_quadrado">2.1. Quadrado</h3>
<div class="sect3">
<h4 id="_questão_3">2.1.1. Questão</h4>
<div class="paragraph">
<p>Utilizando o programa linha.c como referência, implemente um programa quadrado.c. Este programa deverá desenhar numa janela com fundo branco, de dimensões 256x256 pixels, um quadrado vermelho, com vértice superior esquerdo de coordenadas (x, y)= (30, 226) e vértice inferior direito de coordenadas (x, y) = (226, 30). Quando a tecla a (keycode=97) for pressionada, o quadrado deverá ficar com a cor azul. Quando a tecla v (keycode=118) for pressionada, o quadrado deverá voltar à cor vermelha.</p>
</div>
<div class="ulist">
<div class="title">Arquivos:</div>
<ul>
<li>
<p><a href="ex/2/linha.c" target="_blank">linha.c</a></p>
</li>
<li>
<p><a href="ex/2/quadrado.c" target="_blank">quadrado.c</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_código_3">2.1.2. Código</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;

void init(void);
void display(void);
void keyboard(unsigned char key, int x, int y);

int main(int argc, char** argv){
  glutInit(&amp;argc, argv);
  glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB);
  glutInitWindowSize (256, 256);
  glutInitWindowPosition (100, 100);
  glutCreateWindow ("Desenhando um quadrado");
  init();
  glutDisplayFunc(display);
  glutKeyboardFunc(keyboard);
  glutMainLoop();
  return 0;
}

void init(void){
  glClearColor(1.0, 1.0, 1.0, 1.0);
  glOrtho (0, 256, 0, 256, -1 ,1);
  //pinta inicialmente de vermelho
  glColor3f (1.0, 0.0, 0.0);
}

void display(void){
  int i;
  glClear(GL_COLOR_BUFFER_BIT);
  glBegin(GL_LINES);
  glVertex2i(30,226); glVertex2i(226,226);
  glVertex2i(226,226); glVertex2i(226,30);
  glVertex2i(226,30); glVertex2i(30,30);
  glVertex2i(30,30); glVertex2i(30, 226);
  glEnd();
  glFlush();
}

void keyboard(unsigned char key, int x, int y){
  //switch entre Azul e Vermelho
  switch (key) {
    case 'a':
      //escolhe a cor azul
      glColor3f (0.0, 0.0, 1.0);
      //redesenha "display(void)"
      glutPostRedisplay();
      break;
    case 'v':
      glColor3f (1.0, 0.0, 0.0);
      glutPostRedisplay();
      break;
    case 27:
  	exit(0);
  	break;
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_imagem_3">2.1.3. Imagem</h4>
<div class="imageblock">
<div class="content">
<img src="ex/2/quadrado1.png" alt="quadrado1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="ex/2/quadrado2.png" alt="quadrado2">
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_bresenham_linha">2.2. Bresenham Linha</h3>
<div class="sect3">
<h4 id="_questão_4">2.2.1. Questão</h4>
<div class="paragraph">
<p>Implemente o algoritmo de Bresenham para traçado de linhas, utilizando GL_POINTS como parâmetro da função glBegin(). Este parâmetro indica que cada vértice deve ser tratado como um ponto simples. Utilizando o algoritmo implementado, desenhe uma reta verde do ponto (x, y)=(40, 200) ao ponto (x, y)=(200, 10).</p>
</div>
<div class="ulist">
<div class="title">Arquivos:</div>
<ul>
<li>
<p><a href="ex/2/bresenhamLinha.c" target="_blank">bresenhamLinha.c</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_código_4">2.2.2. Código</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;cmath&gt;
#include &lt;stdio.h&gt;

void init(void);
void display(void);
void keyboard(unsigned char key, int x, int y);
void bresenDraw(int x1, int y1, int x2, int y2);
void trash(void);

int main(int argc, char** argv) {
  glutInit(&amp;argc, argv);
  glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB);
  glutInitWindowSize (256, 256);
  glutInitWindowPosition (100, 100);
  glutCreateWindow ("Desenhando uma linha");
  init();
  glutDisplayFunc(display);
  glutKeyboardFunc(keyboard);
  glutMainLoop();
  return 0;
}

void init(void) {
  glClearColor(1.0, 1.0, 1.0, 1.0);
  glOrtho (0, 256, 0, 256, -1 , 1);
}

void display(void) {
  int i;
  glClear(GL_COLOR_BUFFER_BIT);
  glColor3f (0.0, 0.0, 0.0);
  glBegin(GL_POINTS);
  int x0 = 40;
  int x1 = 200;
  int y0 = 200;
  int y1 = 10;

  bresenDraw(40, 200, 200, 10);

  glEnd();
  glFlush();
}

void keyboard(unsigned char key, int x, int y) {
  switch (key) {
  case 27:
    exit(0);
    break;
  }
}

void bresenDraw(int x1, int y1, int x2, int y2) {
  int x = x1;
  int y = y1;
  int Delta_x = abs(x2 - x1);
  int Delta_y = abs(y2 - y1);
  int s1 = (x2 &gt; x1) ? 1 : -1;
  int s2 = (y2 &gt; y1) ? 1 : -1;
  int Troca, i;
  if (Delta_y &gt; Delta_x) {
    int Temp = Delta_x;
    Delta_x = Delta_y;
    Delta_y = Temp;
    Troca = 1;
  }
  else {
    Troca = 0;
  }
  int new_e = 2 * Delta_y - Delta_x;
  for (i = 1; i &lt;= Delta_x; i++) {
    glVertex2i(x, y);
    while (new_e &gt;= 0) {
      if (Troca == 1) {
        //Muda para a proxima linha de rasterização
        x = x + s1;
      }
      else {
        y = y + s2;
      }
      new_e = new_e - 2 * Delta_x;
    }

    //Permanece nesta linha de rasterização
    if (Troca == 1) {
      y = y + s2;
    }
    else {
      x = x + s1;
    }
    new_e = new_e + 2 * Delta_y;
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_imagem_4">2.2.3. Imagem</h4>
<div class="imageblock">
<div class="content">
<img src="ex/2/bresenhamLinha.png" alt="bresenhamLinha">
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_bresenham_círculo">2.3. Bresenham Círculo</h3>
<div class="sect3">
<h4 id="_questão_5">2.3.1. Questão</h4>
<div class="paragraph">
<p>Implemente o algoritmo de Bresenham para traçado de circunferências, utilizando GL_POINTS como parâmetro da função glBegin(). Utilizando o algoritmo implementado, desenhe uma circunferência azul de raio r=50, centrada no ponto (x, y) = (128, 128).</p>
</div>
<div class="ulist">
<div class="title">Arquivos:</div>
<ul>
<li>
<p><a href="ex/2/bresenhamCircle.c" target="_blank">bresenhamCircle.c</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_código_5">2.3.2. Código</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;cmath&gt;
#include &lt;stdio.h&gt;

void init(void);
void display(void);
void keyboard(unsigned char key, int x, int y);
void bresenDraw(int x, int y, int raio);
void pontosDaCircunferencia(int x, int y, int xc, int yc);

int main(int argc, char** argv) {
  glutInit(&amp;argc, argv);
  glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB);
  glutInitWindowSize (256, 256);
  glutInitWindowPosition (100, 100);
  glutCreateWindow ("Desenhando uma linha");
  init();
  glutDisplayFunc(display);
  glutKeyboardFunc(keyboard);
  glutMainLoop();
  return 0;
}

void init(void) {
  glClearColor(1.0, 1.0, 1.0, 1.0);
  glOrtho (0, 256, 0, 256, -1 , 1);
}

void display(void) {
  int i;
  glClear(GL_COLOR_BUFFER_BIT);
  glColor3f (0.0, 0.0, 0.0);
  glBegin(GL_POINTS);

  bresenDraw(128, 128, 50);

  glEnd();
  glFlush();
}

void keyboard(unsigned char key, int x, int y) {
  switch (key) {
  case 27:
    exit(0);
    break;
  }
}

void bresenDraw(int xc, int yc, int raio) {
  int x = 0;
  int y = raio;
  int d = 1 - raio;
  pontosDaCircunferencia(x, y, xc, yc);
  while (y &gt; x) {
    if (d &lt; 0) {
      d = d + 2 * x + 3;
      x = x + 1;
    }
    else {
      d = d + 2 * (x - y) + 5;
      x = x + 1;
      y = y - 1;
    }
    pontosDaCircunferencia(x, y, xc, yc);
  }
}

void pontosDaCircunferencia(int x, int y, int xc, int yc) {
                    //Octantes
  glVertex2i(x+xc,y+yc);  //1
  glVertex2i(y+xc,x+yc);  //2
  glVertex2i(y+xc,-x+yc); //3
  glVertex2i(x+xc,-y+yc); //4
  glVertex2i(-x+xc,-y+yc);//5
  glVertex2i(-y+xc,-x+yc);//6
  glVertex2i(-y+xc,x+yc); //7
  glVertex2i(-x+xc,y+yc); //8
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_imagem_5">2.3.3. Imagem</h4>
<div class="imageblock">
<div class="content">
<img src="ex/2/bresenhamCircle.png" alt="bresenhamCircle">
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_preenchimento_de_regiões">3. Preenchimento de regiões</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_seleção">3.1. Seleção</h3>
<div class="sect3">
<h4 id="_questão_6">3.1.1. Questão</h4>
<div class="paragraph">
<p>Utilizando o programa preenchimento.c como referência, implemente um programa selecao.c. Este programa deverá desenhar numa janela com fundo branco, de dimensões 256x256 pixels, quatro polígonos com as mesmas coordenadas dos polígonos do programa de referência. Todos os polígonos devem estar inicialmente preenchidos de amarelo e com bordas pretas. Quando o usuário clicar com o botão esquerdo do mouse dentro de um dos polígonos, a cor de preechimento deste polígono deverá mudar para uma cor aleatória. Quando a tecla b (keycode=98) for pressionada, o programa passará a mudar as cores das bordas e não mais dos fundos dos polígonos. Quando a tecla f (keycode=102) for pressionada, o programa passará a mudar as cores dos fundos dos polígonos e não mais das bordas.</p>
</div>
<div class="ulist">
<div class="title">Arquivos:</div>
<ul>
<li>
<p><a href="ex/3/preenchimento.c" target="_blank">preenchimento.c</a></p>
</li>
<li>
<p><a href="ex/3/selecao.c" target="_blank">selecao.c</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_código_6">3.1.2. Código</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

GLfloat rb[4], gb[4], bb[4], rf[4], gf[4], bf[4];
int qx[4], qy[4];
int posX, posY;
bool flagKey;
void init(void);
void display(void);
void keyboard(unsigned char key, int x, int y);
void mouse(int button, int state, int x, int y);
void square(int qn);

int main(int argc, char** argv) {
  glutInit(&amp;argc, argv);
  glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB);
  glutInitWindowSize (256, 256);
  glutInitWindowPosition (100, 100);
  glutCreateWindow ("Preenchendo regioes");
  init();
  glutDisplayFunc(display);
  glutKeyboardFunc(keyboard);
  glutMouseFunc(mouse);
  glutMainLoop();
  return 0;
}

void init(void) {
  glClearColor(1.0, 1.0, 1.0, 1.0);
  glOrtho (0, 256, 0, 256, -1 , 1);
  for (int i = 0; i &lt; 4; ++i)
  {
    rb[i] = 0; gb[i] = 0; bb[i] = 0;
    rf[i] = 1; gf[i] = 1; bf[i] = 0;
  }

  flagKey = 1;
  qx[0] = 30;
  qy[0] = 226;
  qx[1] = 143;
  qy[1] = 226;
  qx[2] = 30;
  qy[2] = 113;
  qx[3] = 143;
  qy[3] = 113;
  posX = 0; posY = 0;
}

void display(void) {
  int i;
  glClear(GL_COLOR_BUFFER_BIT);
  glDisable(GL_POLYGON_STIPPLE);

  square(0);
  square(1);
  square(2);
  square(3);

  glFlush();
  glutSwapBuffers();
}

void keyboard(unsigned char key, int x, int y) {
  switch (key) {
  case 'b':
    flagKey = 0;
    break;
  case 'f':
    flagKey = 1;
    break;
  case 27:
    exit(0);
    break;
  }
}

void mouse(int button, int state, int x, int y) {
  posX = x;
  //O eixo y do rastreamento do mouse é o inverso do de desenho do openGL, why!!!???
  posY = (y-256)*-1;
  //posY = y;
  switch (button) {
  case GLUT_LEFT_BUTTON:
    if (state == GLUT_DOWN) {
      //printf("(%d,%d)\n", posX, posY);
      glutPostRedisplay();
    }
    break;
  }
}

void square(int qn) {
  int x = qx[qn];
  int y = qy[qn];
  //printf("Qn=%d, X=%d, Y=%d\n",qn, x, y);
  //printf("(X=%d)\n", (x &lt;= posX &amp;&amp; (x+83) &gt;= posX));
  //printf("(Y=%d)\n", (y &lt;= posY &amp;&amp; (y-83) &gt;= posY));
  if ((x &lt;= posX &amp;&amp; (x+83) &gt;= posX) &amp;&amp; (y &gt;= posY &amp;&amp; (y-83) &lt;= posY))
  {
    if (flagKey)
    {
      rf[qn] = (GLfloat)rand() / (RAND_MAX + 1.0);
      gf[qn] = (GLfloat)rand() / (RAND_MAX + 1.0);
      bf[qn] = (GLfloat)rand() / (RAND_MAX + 1.0);
    } else {
      rb[qn] = (GLfloat)rand() / (RAND_MAX + 1.0);
      gb[qn] = (GLfloat)rand() / (RAND_MAX + 1.0);
      bb[qn] = (GLfloat)rand() / (RAND_MAX + 1.0);
    }
  }
  glPolygonMode(GL_BACK, GL_FILL);
  glColor3f(rf[qn], gf[qn], bf[qn]);
  glBegin(GL_POLYGON);
  glVertex2i(x, y); glVertex2i(x + 83, y);
  glVertex2i(x + 83, y - 83); glVertex2i(x, y - 83);
  glEnd();

  glPolygonMode(GL_BACK, GL_LINE);
  glColor3f(rb[qn], gb[qn], bb[qn]);
  glBegin(GL_POLYGON);
  glVertex2i(x, y); glVertex2i(x + 83, y);
  glVertex2i(x + 83, y - 83); glVertex2i(x, y - 83);
  glEnd();
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_imagem_6">3.1.3. Imagem</h4>
<div class="imageblock">
<div class="content">
<img src="ex/3/selecao1.png" alt="selecao1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="ex/3/selecao2.png" alt="selecao2">
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_seleção_buffer_simples">3.2. Seleção Buffer Simples</h3>
<div class="sect3">
<h4 id="_questão_7">3.2.1. Questão</h4>
<div class="paragraph">
<p>Repita o item anterior utilizando buffer simples e comente os resultados obtidos.</p>
</div>
<div class="ulist">
<div class="title">Arquivos:</div>
<ul>
<li>
<p><a href="ex/3/selecaoBS.c" target="_blank">selecaoBS.c</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_código_7">3.2.2. Código</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

GLfloat rb[4], gb[4], bb[4], rf[4], gf[4], bf[4];
int qx[4], qy[4];
int posX, posY;
bool flagKey;
void init(void);
void display(void);
void keyboard(unsigned char key, int x, int y);
void mouse(int button, int state, int x, int y);
void square(int qn);

int main(int argc, char** argv) {
  glutInit(&amp;argc, argv);
  glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB);
  glutInitWindowSize (256, 256);
  glutInitWindowPosition (100, 100);
  glutCreateWindow ("Preenchendo regioes");
  init();
  glutDisplayFunc(display);
  glutKeyboardFunc(keyboard);
  glutMouseFunc(mouse);
  glutMainLoop();
  return 0;
}

void init(void) {
  glClearColor(1.0, 1.0, 1.0, 1.0);
  glOrtho (0, 256, 0, 256, -1 , 1);
  for (int i = 0; i &lt; 4; ++i)
  {
    rb[i] = 0; gb[i] = 0; bb[i] = 0;
    rf[i] = 1; gf[i] = 1; bf[i] = 0;
  }

  flagKey = 1;
  qx[0] = 30;
  qy[0] = 226;
  qx[1] = 143;
  qy[1] = 226;
  qx[2] = 30;
  qy[2] = 113;
  qx[3] = 143;
  qy[3] = 113;
  posX = 0; posY = 0;
}

void display(void) {
  int i;
  glClear(GL_COLOR_BUFFER_BIT);
  glDisable(GL_POLYGON_STIPPLE);

  square(0);
  square(1);
  square(2);
  square(3);

  glFlush();
  //glutSwapBuffers();
}

void keyboard(unsigned char key, int x, int y) {
  switch (key) {
  case 'b':
    flagKey = 0;
    break;
  case 'f':
    flagKey = 1;
    break;
  case 27:
    exit(0);
    break;
  }
}

void mouse(int button, int state, int x, int y) {
  posX = x;
  //O eixo y do rastreamento do mouse é o inverso do de desenho do openGL, why!!!???
  posY = (y-256)*-1;
  //posY = y;
  switch (button) {
  case GLUT_LEFT_BUTTON:
    if (state == GLUT_DOWN) {
      //printf("(%d,%d)\n", posX, posY);
      glutPostRedisplay();
    }
    break;
  }
}

void square(int qn) {
  int x = qx[qn];
  int y = qy[qn];
  //printf("Qn=%d, X=%d, Y=%d\n",qn, x, y);
  //printf("(X=%d)\n", (x &lt;= posX &amp;&amp; (x+83) &gt;= posX));
  //printf("(Y=%d)\n", (y &lt;= posY &amp;&amp; (y-83) &gt;= posY));
  if ((x &lt;= posX &amp;&amp; (x+83) &gt;= posX) &amp;&amp; (y &gt;= posY &amp;&amp; (y-83) &lt;= posY))
  {
    if (flagKey)
    {
      rf[qn] = (GLfloat)rand() / (RAND_MAX + 1.0);
      gf[qn] = (GLfloat)rand() / (RAND_MAX + 1.0);
      bf[qn] = (GLfloat)rand() / (RAND_MAX + 1.0);
    } else {
      rb[qn] = (GLfloat)rand() / (RAND_MAX + 1.0);
      gb[qn] = (GLfloat)rand() / (RAND_MAX + 1.0);
      bb[qn] = (GLfloat)rand() / (RAND_MAX + 1.0);
    }
  }
  glPolygonMode(GL_BACK, GL_FILL);
  glColor3f(rf[qn], gf[qn], bf[qn]);
  glBegin(GL_POLYGON);
  glVertex2i(x, y); glVertex2i(x + 83, y);
  glVertex2i(x + 83, y - 83); glVertex2i(x, y - 83);
  glEnd();

  glPolygonMode(GL_BACK, GL_LINE);
  glColor3f(rb[qn], gb[qn], bb[qn]);
  glBegin(GL_POLYGON);
  glVertex2i(x, y); glVertex2i(x + 83, y);
  glVertex2i(x + 83, y - 83); glVertex2i(x, y - 83);
  glEnd();
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_imagem_7">3.2.3. Imagem</h4>
<div class="imageblock">
<div class="content">
<img src="ex/3/selecaoBS.png" alt="selecaoBS">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_comentário">3.2.4. Comentário</h4>
<div class="paragraph">
<p>Meus olhos destreinados não foram capazes de notar nenhuma alteração após alterar de DOUBLE para SINGLE e desabilitar o swap.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_padrão_hg">3.3. Padrão HG</h3>
<div class="sect3">
<h4 id="_questão_8">3.3.1. Questão</h4>
<div class="paragraph">
<p>Crie um padrão de preenchimento com as iniciais dos seu nome e sobre nome, por exemplo, AB, para Agostinho Brito. Implemente um programa que desenhe em uma janela de fundo branco de dimensões 300x300 pixels um hexágono com bounding box de dimensões 200x200 pixels. O hexágono deve estar centrado na tela e preenchido com cor azul, utilize este padrão de preenchimento criado.</p>
</div>
<div class="ulist">
<div class="title">Arquivos:</div>
<ul>
<li>
<p><a href="ex/3/padrao.c" target="_blank">padrao.c</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_código_8">3.3.2. Código</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;

GLubyte tux[] = {
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x08, 0x20, 0x03, 0xF8,
  0x08, 0x20, 0x02, 0x08,
  0x08, 0x20, 0x02, 0x08,
  0x08, 0x20, 0x02, 0x08,
  0x08, 0x20, 0x02, 0x08,
  0x08, 0x20, 0x02, 0x08,
  0x08, 0x20, 0x02, 0x08,
  0x08, 0x20, 0x02, 0x08,
  0x08, 0x20, 0x02, 0x08,
  0x08, 0x20, 0x02, 0x08,
  0x08, 0x20, 0x02, 0x08,
  0x08, 0x20, 0x02, 0x08,
  0x0F, 0xE0, 0x02, 0x38,
  0x08, 0x20, 0x02, 0x00,
  0x08, 0x20, 0x02, 0x00,
  0x08, 0x20, 0x02, 0x00,
  0x08, 0x20, 0x02, 0x00,
  0x08, 0x20, 0x02, 0x00,
  0x08, 0x20, 0x02, 0x00,
  0x08, 0x20, 0x02, 0x00,
  0x08, 0x20, 0x02, 0x00,
  0x08, 0x20, 0x02, 0x00,
  0x08, 0x20, 0x02, 0x00,
  0x08, 0x20, 0x03, 0xF8,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00
};

GLfloat r, g, b;

void init(void);
void display(void);
void keyboard(unsigned char key, int x, int y);
void mouse(int button, int state, int x, int y);

int main(int argc, char** argv) {
  glutInit(&amp;argc, argv);
  glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB);
  glutInitWindowSize (300, 300);
  glutInitWindowPosition (100, 100);
  glutCreateWindow ("Preenchendo regiões");
  init();
  glutDisplayFunc(display);
  glutKeyboardFunc(keyboard);
  glutMouseFunc(mouse);
  glutMainLoop();
  return 0;
}

void init(void) {
  glClearColor(1.0, 1.0, 1.0, 1.0);
  glOrtho (0, 300, 0, 300, -1 , 1);
  r = 0; g = 0; b = 1;
}

void display(void) {
  int i;
  glClear(GL_COLOR_BUFFER_BIT);
  glDisable(GL_POLYGON_STIPPLE);

  glEnable(GL_POLYGON_STIPPLE);
  glColor3f(r, g, 1.0);
  glPolygonStipple(tux);
  glBegin(GL_POLYGON);
  glVertex2i(100, 63); glVertex2i(50, 150); glVertex2i(100, 237);
  glVertex2i(200, 237); glVertex2i(250, 150); glVertex2i(200, 63);
  glEnd();
  glFlush();
  glutSwapBuffers();
}

void keyboard(unsigned char key, int x, int y) {
  switch (key) {
  case 27:
    exit(0);
    break;
  }
}

void mouse(int button, int state, int x, int y) {
  switch (button) {
  case GLUT_LEFT_BUTTON:
    if (state == GLUT_DOWN) {
      r = (GLfloat)rand() / (RAND_MAX + 1.0);
      g = (GLfloat)rand() / (RAND_MAX + 1.0);
      b = (GLfloat)rand() / (RAND_MAX + 1.0);
      glutPostRedisplay();
    }
    break;
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_imagem_8">3.3.3. Imagem</h4>
<div class="imageblock">
<div class="content">
<img src="ex/3/padrao.png" alt="padrao">
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_transformações_geométricas">4. Transformações Geométricas</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_braço_garra">4.1. Braço Garra</h3>
<div class="sect3">
<h4 id="_questão_9">4.1.1. Questão</h4>
<div class="paragraph">
<p>Utilizando o programa braco.c como referência, implemente um programa braco-garra.c. Este programa deverá acrescente ao braço robótico uma garra com três dedos, sendo um indicador, um médio e um polegar, como mostra a Figura 4.3. O usuário deverá poder rotacionar o dedo indicador com as teclas i e I, nos sentidos horário e anti-horário. Da mesma forma, as teclas p P deverão rotacionar o polegar, e teclas m M, o dedo médio do robô.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="ex/4/Figura4.3.png" alt="Figura4.3">
</div>
</div>
<div class="ulist">
<div class="title">Arquivos:</div>
<ul>
<li>
<p><a href="ex/4/braco.c" target="_blank">braco.c</a></p>
</li>
<li>
<p><a href="ex/4/braco-garra.c" target="_blank">braco-garra.c</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_código_9">4.1.2. Código</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;

static int shoulder = 0, elbow = 0, thumb = 0, index = 0, middle = 0;

void init(void){
  glClearColor (0.0, 0.0, 0.0, 0.0);
}

void display(void){
  glClear (GL_COLOR_BUFFER_BIT);
  glPushMatrix();

  /* origem posicionada no ombro */
  glTranslatef (-1.0, 0.0, 0.0);
  glRotatef ((GLfloat) shoulder, 0.0, 0.0, 1.0);

  /* origem posicionada no centro do braco */
  glTranslatef (1.0, 0.0, 0.0);
  glPushMatrix();
  glScalef (2.0, 0.4, 1.0);
  glutWireCube (1.0);
  glPopMatrix();

  /* origem posicionada no cotovelo */
  glTranslatef (1.0, 0.0, 0.0);
  glRotatef ((GLfloat) elbow, 0.0, 0.0, 1.0);
  glTranslatef (1.0, 0.0, 0.0);
  glPushMatrix();
  glScalef (2.0, 0.4, 1.0);
  glutWireCube (1.0);
  glPopMatrix();

  /* origem posicionada no dedao */
	glTranslatef (1.0, 0.0, 0.0);
	glPushMatrix();
  glTranslatef (0.0, -0.2, 0.0);
  glRotatef ((GLfloat) thumb, 0.0, 0.0, 1.0);
  glTranslatef (0.25, 0.0, 0.0);
	glScalef (0.5, 0.1, 0.33);
  glutWireCube (1.0);
  glPopMatrix();

  /* origem posicionada no indicador */
  glTranslatef (0.0, 0.2, 0.0);
	glPushMatrix();
	glTranslatef (0.0, 0.0, 0.25);
  glRotatef ((GLfloat) index, 0.0, 0.0, 1.0);
  glTranslatef (0.25, 0.0, 0.0);
	glScalef (0.5, 0.1, 0.33);
  glutWireCube (1.0);
  glPopMatrix();

  /* origem posicionada no middle */
	glTranslatef (0.0, 0.0, -0.25);
  glRotatef ((GLfloat) middle, 0.0, 0.0, 1.0);
  glTranslatef (0.25, 0.0, 0.0);
	glScalef (0.5, 0.1, 0.33);
  glutWireCube (1.0);
  glPopMatrix();

  /* origem volta para o sistema de coordenadas original */
  glPopMatrix();
  glutSwapBuffers();
}

void reshape (int w, int h){
  glViewport (0, 0, (GLsizei) w, (GLsizei) h);
  glMatrixMode (GL_PROJECTION);
  glLoadIdentity ();
  gluPerspective(65.0, (GLfloat) w/(GLfloat) h, 1.0, 20.0);
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  glTranslatef (0.0, 0.0, -10.0);
}

void keyboard (unsigned char key, int x, int y){
  switch (key) {
  case 's':
    shoulder = (shoulder + 5) % 360;
    glutPostRedisplay();
    break;
  case 'S':
    shoulder = (shoulder - 5) % 360;
    glutPostRedisplay();
    break;
  case 'e':
    elbow = (elbow + 5) % 360;
    glutPostRedisplay();
    break;
  case 'E':
    elbow = (elbow - 5) % 360;
    glutPostRedisplay();
    break;
  case 'p':
    thumb = (thumb + 5) % 360;
    glutPostRedisplay();
    break;
  case 'P':
    thumb = (thumb - 5) % 360;
    glutPostRedisplay();
    break;
  case 'i':
    index = (index + 5) % 360;
    glutPostRedisplay();
    break;
  case 'I':
    index = (index - 5) % 360;
    glutPostRedisplay();
    break;
  case 'm':
    middle = (middle + 5) % 360;
    glutPostRedisplay();
    break;
  case 'M':
    middle = (middle - 5) % 360;
    glutPostRedisplay();
    break;
  case 27:
    exit(0);
    break;
  default:
    break;
  }
}

int main(int argc, char** argv){
  glutInit(&amp;argc, argv);
  glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB);
  glutInitWindowSize (600, 600);
  glutInitWindowPosition (100, 100);
  glutCreateWindow (argv[0]);
  init ();
  glutDisplayFunc(display);
  glutReshapeFunc(reshape);
  glutKeyboardFunc(keyboard);
  glutMainLoop();
  return 0;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_imagem_9">4.1.3. Imagem</h4>
<div class="imageblock">
<div class="content">
<img src="ex/4/braco-garra1.png" alt="braco garra1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="ex/4/braco-garra2.png" alt="braco garra2">
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_braço_garra_3d">4.2. Braço Garra 3D</h3>
<div class="sect3">
<h4 id="_questão_10">4.2.1. Questão</h4>
<div class="paragraph">
<p>Copie o programa braco-garra.c que você criou com o nome braco-garra-3d.c. Neste novo programa, modifique o trecho da função main() que define o modo de apresentação no GLUT. Use a seguinte chamada para a função de inicialização: glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH), pois inclui o tratamento de profundidade e de superfícies escondidas no OpenGL . Além disso, ao invés de utilizar chamadas à função glutWireCube(), inclua chamadas apenas à função glutSolidCube(), que contém os mesmos argumentos. Acrescente à função init() as chamadas de função glEnable(GL_DEPTH_TEST); e glEnable(GL_CULL_FACE);, de modo que o tratamento de superfícies escondidas seja feito pelo OpenGL. Utilize cores diferentes para cada uma das partes do braço, de modo a obter um modelo semelhante ao da Figura 4.4. Possibilite também que a base do robô seja rotacionada em torno do eixo y, usando as teclas b e B, para girar nos sentidos horário e anti-horário.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="ex/4/Figura4.4.png" alt="Figura4.4">
</div>
</div>
<div class="ulist">
<div class="title">Arquivos:</div>
<ul>
<li>
<p><a href="ex/4/braco.c" target="_blank">braco-garra.c</a></p>
</li>
<li>
<p><a href="ex/4/braco-garra.c" target="_blank">braco-garra-3d.c</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_código_10">4.2.2. Código</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;

static int shoulder = 0, elbow = 0, thumb = 0, index = 0, middle = 0, base = 0;

void init(void){
  glClearColor (0.0, 0.0, 0.0, 0.0);
  //glEnable(GL_DEPTH_TEST); // Deveria ter essa linha, mas quando coloco quebra no meu laptop
  glEnable(GL_CULL_FACE);
}

void display(void){
  glClear (GL_COLOR_BUFFER_BIT);
  glPushMatrix();

  /* origem posicionada no ombro */
  glTranslatef (-1.0, 0.0, 0.0);
  glRotatef ((GLfloat) base, 0.0, 1.0, 0.0);
  glRotatef ((GLfloat) shoulder, 0.0, 0.0, 1.0);

  /* origem posicionada no centro do braco */
  glTranslatef (1.0, 0.0, 0.0);
  glPushMatrix();
  glScalef (2.0, 0.4, 1.0);
  glColor3f(1.0, 0.0, 0.0);
  glutSolidCube(1.0);
  glPopMatrix();

  /* origem posicionada no cotovelo */
  glTranslatef (1.0, 0.0, 0.0);
  glRotatef ((GLfloat) elbow, 0.0, 0.0, 1.0);
  glTranslatef (1.0, 0.0, 0.0);
  glPushMatrix();
  glScalef (2.0, 0.4, 1.0);
  glColor3f(0.0, 1.0, 0.0);
  glutSolidCube(1.0);
  glPopMatrix();

  /* origem posicionada no dedao */
	glTranslatef (1.0, 0.0, 0.0);
	glPushMatrix();
  glTranslatef (0.0, -0.2, 0.0);
  glRotatef ((GLfloat) thumb, 0.0, 0.0, 1.0);
  glTranslatef (0.25, 0.0, 0.0);
	glScalef (0.5, 0.1, 0.33);
  glColor3f(0.0, 0.0, 1.0);
  glutSolidCube(1.0);
  glPopMatrix();

  /* origem posicionada no indicador */
  glTranslatef (0.0, 0.2, 0.0);
	glPushMatrix();
	glTranslatef (0.0, 0.0, 0.33);
  glRotatef ((GLfloat) index, 0.0, 0.0, 1.0);
  glTranslatef (0.25, 0.0, 0.0);
	glScalef (0.5, 0.1, 0.33);
  glColor3f(1.0, 1.0, 0.0);
  glutSolidCube(1.0);
  glPopMatrix();

  /* origem posicionada no middle */
	glTranslatef (0.0, 0.0, -0.33);
  glRotatef ((GLfloat) middle, 0.0, 0.0, 1.0);
  glTranslatef (0.25, 0.0, 0.0);
	glScalef (0.5, 0.1, 0.33);
  glColor3f(1.0, 0.0, 1.0);
  glutSolidCube(1.0);
  glPopMatrix();

  /* origem volta para o sistema de coordenadas original */
  glPopMatrix();
  glutSwapBuffers();
}

void reshape (int w, int h){
  glViewport (0, 0, (GLsizei) w, (GLsizei) h);
  glMatrixMode (GL_PROJECTION);
  glLoadIdentity ();
  gluPerspective(65.0, (GLfloat) w/(GLfloat) h, 1.0, 20.0);
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  glTranslatef (0.0, 0.0, -10.0);
}

void keyboard (unsigned char key, int x, int y){
  switch (key) {
  case 's':
    shoulder = (shoulder + 5) % 360;
    glutPostRedisplay();
    break;
  case 'S':
    shoulder = (shoulder - 5) % 360;
    glutPostRedisplay();
    break;
  case 'e':
    elbow = (elbow + 5) % 360;
    glutPostRedisplay();
    break;
  case 'E':
    elbow = (elbow - 5) % 360;
    glutPostRedisplay();
    break;
  case 'p':
    thumb = (thumb + 5) % 360;
    glutPostRedisplay();
    break;
  case 'P':
    thumb = (thumb - 5) % 360;
    glutPostRedisplay();
    break;
  case 'i':
    index = (index + 5) % 360;
    glutPostRedisplay();
    break;
  case 'I':
    index = (index - 5) % 360;
    glutPostRedisplay();
    break;
  case 'm':
    middle = (middle + 5) % 360;
    glutPostRedisplay();
    break;
  case 'M':
    middle = (middle - 5) % 360;
    glutPostRedisplay();
    break;
  case 'b':
    base = (base + 5) % 360;
    glutPostRedisplay();
    break;
  case 'B':
    base = (base - 5) % 360;
    glutPostRedisplay();
    break;
  case 27:
    exit(0);
    break;
  default:
    break;
  }
}

int main(int argc, char** argv){
  glutInit(&amp;argc, argv);
  glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
  glutInitWindowSize (600, 600);
  glutInitWindowPosition (100, 100);
  glutCreateWindow (argv[0]);
  init ();
  glutDisplayFunc(display);
  glutReshapeFunc(reshape);
  glutKeyboardFunc(keyboard);
  glutMainLoop();
  return 0;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_imagem_10">4.2.3. Imagem</h4>
<div class="imageblock">
<div class="content">
<img src="ex/4/braco-garra-3d1.png" alt="braco garra 3d1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="ex/4/braco-garra-3d3.png" alt="braco garra 3d3">
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_projeções_geométricas">5. Projeções geométricas</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_tipos_de_projeções">5.1. Tipos de Projeções</h3>
<div class="sect3">
<h4 id="_questão_11">5.1.1. Questão</h4>
<div class="paragraph">
<p>Utilizando o programa projecoes.c como referência, implemente um programa tiposdeprojecoes.c. Este programa deverá conter mais sete opções de teclado: t e f, para exibir o topo e o fundo do objeto, F e T, para mostrar a frente e a face traseira, e e d, para mostrar a faces esquerda e direita, respectivamente, e a tecla c, para mostrar o triângulo do canto.</p>
</div>
<div class="ulist">
<div class="title">Arquivos:</div>
<ul>
<li>
<p><a href="ex/5/projecoes.c" target="_blank">projecoes.c</a></p>
</li>
<li>
<p><a href="ex/5/tiposdeprojecoes.c" target="_blank">tiposdeprojecoes.c</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_código_11">5.1.2. Código</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

void init(void);
void display(void);
void keyboard(unsigned char key, int x, int y);
void reshape (int w, int h);

#define AZUL     0.0, 0.0, 1.0
#define VERMELHO 1.0, 0.0, 0.0
#define AMARELO  1.0, 1.0, 0.0
#define VERDE    0.0, 1.0, 0.0
#define CYAN     1.0, 0.0, 1.0
#define LARANJA  0.8, 0.6, 0.1
#define ROSEO    0.7, 0.1, 0.6
#define CINZA    0.6, 0.6, 0.6

static GLfloat vertices[30]={
  0.0,  30.0, 30.0, /* 0 */
  20.0, 30.0, 30.0, /* 1 */
  30.0, 20.0, 30.0, /* 2 */
  30.0,  0.0, 30.0, /* 3 */
  0.0,   0.0, 30.0, /* 4 */
  0.0,  30.0,  0.0, /* 5 */
  30.0, 30.0,  0.0, /* 6 */
  30.0,  0.0,  0.0, /* 7 */
  0.0,   0.0,  0.0, /* 8 */
  30.0, 30.0, 20.0  /* 9 */
};

static GLubyte frenteIndices[]    = {0,4,3,2,1};
static GLubyte trasIndices[]      = {5,6,7,8};
static GLubyte esquerdaIndices[]  = {0,5,8,4};
static GLubyte direitaIndices[]   = {2,3,7,6,9};
static GLubyte topoIndices[]      = {0,1,9,6,5};
static GLubyte fundoIndices[]     = {3,4,8,7};
static GLubyte trianguloIndices[] = {1,2,9};

static int eixoy, eixox;
int largura, altura;

int main(int argc, char** argv){
  int i;
  glutInit(&amp;argc, argv);
  glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB);
  glutInitWindowSize (256, 256);
  glutInitWindowPosition (100, 100);
  glutCreateWindow (argv[0]);
  init();
  glutDisplayFunc(display);
  glutKeyboardFunc(keyboard);
  glutReshapeFunc(reshape);
  glutMainLoop();
  return 0;
}

void init(void){
  glClearColor(0.0, 0.0, 0.0, 0.0);
  glOrtho (-50, 50, -50, 50, -50 , 50);
  glEnable(GL_DEPTH_TEST);
  glEnable(GL_CULL_FACE);
}

void reshape (int w, int h){
  glViewport (0, 0, (GLsizei) w, (GLsizei) h);
  largura=w;
  altura=h;
}

void display(void){
  glPushMatrix();
  glRotatef ((GLfloat) eixoy, 0.0, 1.0, 0.0);
  glRotatef ((GLfloat) eixox, 1.0, 0.0, 0.0);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );

  glEnableClientState(GL_VERTEX_ARRAY);
  glVertexPointer(3, GL_FLOAT, 0, vertices);

  glColor3f (AZUL); /* frente */
  glDrawElements(GL_POLYGON, 5, GL_UNSIGNED_BYTE, frenteIndices);

  glColor3f (AMARELO); /* esquerda */
  glDrawElements(GL_POLYGON, 4, GL_UNSIGNED_BYTE, esquerdaIndices);

  glColor3f (VERMELHO); /* tras */
  glDrawElements(GL_POLYGON, 4, GL_UNSIGNED_BYTE, trasIndices);

  glColor3f (VERDE); /* direita */
  glDrawElements(GL_POLYGON, 5, GL_UNSIGNED_BYTE, direitaIndices);

  glColor3f (CYAN); /* topo */
  glDrawElements(GL_POLYGON, 5, GL_UNSIGNED_BYTE, topoIndices);

  glColor3f (LARANJA); /* fundo */
  glDrawElements(GL_QUADS, 4, GL_UNSIGNED_BYTE, fundoIndices);

  glColor3f (CINZA); /* triangulo */
  glDrawElements(GL_POLYGON, 3, GL_UNSIGNED_BYTE, trianguloIndices);

  glDisableClientState (GL_VERTEX_ARRAY);

  glPopMatrix();
  glutSwapBuffers();
}

void keyboard(unsigned char key, int x, int y){
  switch (key) {
  case 27:
    exit(0);
    break;
  case 'a':
    printf("%d, %d\n",x,y);
    break;
  case 'y':
    eixoy = (eixoy + 5) % 360;
    glutPostRedisplay();
    break;
  case 'Y':
    eixoy = (eixoy - 5) % 360;
    glutPostRedisplay();
    break;
  case 'x':
    eixox = (eixox + 5) % 360;
    glutPostRedisplay();
    break;
  case 'X':
    eixox = (eixox - 5) % 360;
    glutPostRedisplay();
    break;
  case 'p':
    glLoadIdentity();
    gluPerspective(65.0, (GLfloat) largura/(GLfloat) altura, 20.0, 120.0);
    gluLookAt(0, 0, -90, 0, 0, 0, 0, 1, 0);
    glutPostRedisplay();
    break;
  case 'o':
    glLoadIdentity();
    glOrtho (-50, 50, -50, 50, -50 , 50);
    glutPostRedisplay();
    break;
  case 't':
    eixox = 90;
    eixoy = 0;
    glutPostRedisplay();
    break;
  case 'f':
    eixox = 270;
    eixoy = 0;
    glutPostRedisplay();
    break;
  case 'T':
    eixox = 0;
    eixoy = 180;
    glutPostRedisplay();
    break;
  case 'F':
    eixox = 0;
    eixoy = 0;
    glutPostRedisplay();
    break;
  case 'd':
    eixox = 0;
    eixoy =270;
    glutPostRedisplay();
    break;
  case 'e':
    eixox = 0;
    eixoy = 90;
    glutPostRedisplay();
    break;
  case 'c':
    eixox = 45;
    eixoy = -45;
    glutPostRedisplay();
    break;
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_imagem_11">5.1.3. Imagem</h4>
<div class="imageblock">
<div class="content">
<img src="ex/5/tiposdeprojecoes1.png" alt="tiposdeprojecoes1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="ex/5/tiposdeprojecoes2.png" alt="tiposdeprojecoes2">
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_projeções_animadas">5.2. Projeções Animadas</h3>
<div class="paragraph">
<p>A função glutIdleFunc() é usada pelo GLUT para realizar operações em segundo plano ou animações, enquanto não recebe eventos de sistema. O seu protótipo é:</p>
</div>
<div class="paragraph">
<p>void glutIdleFunc(  *func);
void *func(void);</p>
</div>
<div class="paragraph">
<p>Tomando como base o programa projecoes.c, utilizando a função glutIdleFunc() e crie uma função de retorno idle(). Nesta função, os valores dos ângulos eixox e eixoy devem ser incrementados de valores constantes pequenos e diferentes, de modo a possibilitar uma animação. Utilize a função usleep() para introduzir retardos entre as apresentações dos quadros da animação, tornando mais agradável a visualização. Mantenhas as teclas o e p para chavear entre projeções ortogonais e de perspectiva.</p>
</div>
<div class="ulist">
<div class="title">Arquivos:</div>
<ul>
<li>
<p><a href="ex/5/projecoes.c" target="_blank">projecoes.c</a></p>
</li>
<li>
<p><a href="ex/5/projecoesAnimadas.c" target="_blank">projecoesAnimadas.c</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_código_12">5.2.1. Código</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

void init(void);
void display(void);
void keyboard(unsigned char key, int x, int y);
void reshape (int w, int h);
void idle(void);

#define AZUL     0.0, 0.0, 1.0
#define VERMELHO 1.0, 0.0, 0.0
#define AMARELO  1.0, 1.0, 0.0
#define VERDE    0.0, 1.0, 0.0
#define CYAN     1.0, 0.0, 1.0
#define LARANJA  0.8, 0.6, 0.1
#define ROSEO    0.7, 0.1, 0.6
#define CINZA    0.6, 0.6, 0.6

static GLfloat vertices[30]={
  0.0,  30.0, 30.0, /* 0 */
  20.0, 30.0, 30.0, /* 1 */
  30.0, 20.0, 30.0, /* 2 */
  30.0,  0.0, 30.0, /* 3 */
  0.0,   0.0, 30.0, /* 4 */
  0.0,  30.0,  0.0, /* 5 */
  30.0, 30.0,  0.0, /* 6 */
  30.0,  0.0,  0.0, /* 7 */
  0.0,   0.0,  0.0, /* 8 */
  30.0, 30.0, 20.0  /* 9 */
};

static GLubyte frenteIndices[]    = {0,4,3,2,1};
static GLubyte trasIndices[]      = {5,6,7,8};
static GLubyte esquerdaIndices[]  = {0,5,8,4};
static GLubyte direitaIndices[]   = {2,3,7,6,9};
static GLubyte topoIndices[]      = {0,1,9,6,5};
static GLubyte fundoIndices[]     = {3,4,8,7};
static GLubyte trianguloIndices[] = {1,2,9};

static int eixoy, eixox;
int largura, altura;

int main(int argc, char** argv){
  int i;
  glutInit(&amp;argc, argv);
  glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB);
  glutInitWindowSize (256, 256);
  glutInitWindowPosition (100, 100);
  glutCreateWindow (argv[0]);
  init();
  glutDisplayFunc(display);
  glutKeyboardFunc(keyboard);
  glutReshapeFunc(reshape);
  glutMainLoop();
  return 0;
}

void init(void){
  glClearColor(0.0, 0.0, 0.0, 0.0);
  glOrtho (-50, 50, -50, 50, -50 , 50);
  glEnable(GL_DEPTH_TEST);
  glEnable(GL_CULL_FACE);
}

void reshape (int w, int h){
  glViewport (0, 0, (GLsizei) w, (GLsizei) h);
  largura=w;
  altura=h;
}

void display(void){
  glPushMatrix();
  glRotatef ((GLfloat) eixoy, 0.0, 1.0, 0.0);
  glRotatef ((GLfloat) eixox, 1.0, 0.0, 0.0);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );

  glEnableClientState(GL_VERTEX_ARRAY);
  glVertexPointer(3, GL_FLOAT, 0, vertices);

  glColor3f (AZUL); /* frente */
  glDrawElements(GL_POLYGON, 5, GL_UNSIGNED_BYTE, frenteIndices);

  glColor3f (AMARELO); /* esquerda */
  glDrawElements(GL_POLYGON, 4, GL_UNSIGNED_BYTE, esquerdaIndices);

  glColor3f (VERMELHO); /* tras */
  glDrawElements(GL_POLYGON, 4, GL_UNSIGNED_BYTE, trasIndices);

  glColor3f (VERDE); /* direita */
  glDrawElements(GL_POLYGON, 5, GL_UNSIGNED_BYTE, direitaIndices);

  glColor3f (CYAN); /* topo */
  glDrawElements(GL_POLYGON, 5, GL_UNSIGNED_BYTE, topoIndices);

  glColor3f (LARANJA); /* fundo */
  glDrawElements(GL_QUADS, 4, GL_UNSIGNED_BYTE, fundoIndices);

  glColor3f (CINZA); /* triangulo */
  glDrawElements(GL_POLYGON, 3, GL_UNSIGNED_BYTE, trianguloIndices);

  glDisableClientState (GL_VERTEX_ARRAY);

  glPopMatrix();

  glutSwapBuffers();

  glutIdleFunc(idle);
}

void keyboard(unsigned char key, int x, int y){
  switch (key) {
  case 27:
    exit(0);
    break;
  case 'a':
    printf("%d, %d\n",x,y);
    break;
  case 'p':
    glLoadIdentity();
    gluPerspective(65.0, (GLfloat) largura/(GLfloat) altura, 20.0, 120.0);
    gluLookAt(0, 0, -90, 0, 0, 0, 0, 1, 0);
    glutPostRedisplay();
    break;
  case 'o':
    glLoadIdentity();
    glOrtho (-50, 50, -50, 50, -50 , 50);
    glutPostRedisplay();
    break;
  }
}
void idle(void) {

  eixox = (eixox + 1) % 360;
  eixoy = (eixoy + 1) % 360;
  glutPostRedisplay();
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_imagem_12">5.2.2. Imagem</h4>
<div class="imageblock">
<div class="content">
<img src="ex/5/projecoesAnimadas1.png" alt="projecoesAnimadas1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="ex/5/projecoesAnimadas2.png" alt="projecoesAnimadas2">
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_curvas_no_plano">6. Curvas no plano</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_funcionalidades">6.1. Funcionalidades</h3>
<div class="sect3">
<h4 id="_questão_12">6.1.1. Questão</h4>
<div class="paragraph">
<p>Comente as funcionalidades das curvas de Bézier e NURBS utilizadas neste exemplo.</p>
</div>
<div class="ulist">
<div class="title">Arquivos:</div>
<ul>
<li>
<p><a href="ex/6/splines2d.c" target="_blank">splines2d.c</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_código_13">6.1.2. Código</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;stdlib.h&gt;
#include &lt;GL/glut.h&gt;
#include &lt;math.h&gt;

GLint nVertices=6;
GLfloat vertices[6][3] = {
  {-4.0,  0.0, 0.0},
  {-4.0, +4.0, 0.0},
  {+4.0, -4.0, 0.0},
  {-4.0, -4.0, 0.0},
  {+4.0, +4.0, 0.0},
  {+4.0,  0.0, 0.0}
};

GLint largura, altura;
GLint mudaCurva=0;
GLint verticeCorrente=0;

GLfloat esquerda=-5;
GLfloat direita =+5;
GLfloat fundo   =-5;
GLfloat topo    =+5;
GLfloat longe   =+5;
GLfloat perto   =-5;

enum {BEZIER, NURBS};
GLint spline;
GLUnurbsObj *nc;
GLfloat nos[10]={0.0, 0.0, 0.0, 0.0, 1.0, 2.5, 3.0, 3.0, 3.0, 3.0};
GLint nNos=10;

GLint matrizViewport[4];
GLdouble matrizModelview[16], matrizProjecao[16];
GLint yreal;  /*  posição da coordenada y no OpenGL */
GLdouble wx, wy, wz;  /*  coordenadas no mundo real: x, y, z  */

void display(void){
  int i;
  glClear(GL_COLOR_BUFFER_BIT);
  switch(spline){
  case BEZIER:
    glMap1f(GL_MAP1_VERTEX_3, 0.0, 1.0, 3, nVertices, &amp;vertices[0][0]);
    glBegin(GL_LINE_STRIP);
    for (i = 0; i &lt;= 30; i++){
      glEvalCoord1f((GLfloat) i/30.0);
    }
    glEnd();
    break;
  case NURBS:
    gluBeginCurve(nc);
    gluNurbsCurve(nc, nNos, nos, 3, &amp;vertices[0][0], 4, GL_MAP1_VERTEX_3);
    gluEndCurve(nc);
    break;
  }
  glPointSize(5.0);
  glColor3f(1.0, 1.0, 0.0);
  glBegin(GL_LINE_STRIP);
  for (i = 0; i &lt; nVertices; i++)
    glVertex3fv(&amp;vertices[i][0]);
  glEnd();
  glColor3f(1.0, 0.0, 0.0);
  glBegin(GL_POINTS);
  for (i = 0; i &lt; nVertices; i++)
    glVertex3fv(&amp;vertices[i][0]);
  glEnd();
  glColor3f(1.0, 1.0, 1.0);
  glFlush();
  glutSwapBuffers();
}

void init(void){
  glClearColor(0.0, 0.0, 0.0, 0.0);
  spline=BEZIER;
  nc= gluNewNurbsRenderer();
  gluNurbsProperty(nc, GLU_SAMPLING_TOLERANCE, 5.0);
  glEnable(GL_MAP1_VERTEX_3);
  display();
}

void reshape(int w, int h)
{
  glViewport(0, 0, (GLsizei) w, (GLsizei) h);
  glMatrixMode(GL_PROJECTION);
  largura=w;
  altura=h;
  glLoadIdentity();
  glOrtho(esquerda,direita, fundo, topo, perto, longe);
  glMatrixMode(GL_MODELVIEW);
  glGetIntegerv(GL_VIEWPORT, matrizViewport);
  glGetDoublev(GL_MODELVIEW_MATRIX, matrizModelview);
  glGetDoublev(GL_PROJECTION_MATRIX, matrizProjecao);
  glLoadIdentity();
  glutSwapBuffers();
}

/* ARGSUSED1 */
void keyboard(unsigned char key, int x, int y)
{
  switch (key) {
  case 'b':
    spline = BEZIER;
    glutPostRedisplay();
    break;
  case 'n':
    spline = NURBS;
    glutPostRedisplay();
    break;
  case 27:
    exit(0);
    break;
  }
}

void proximidade(){
  int i;
  double tam=0, tamin=32000;
  verticeCorrente=0;
  for(i=0; i&lt;nVertices; i++){
    tam = (wx-vertices[i][0])*(wx-vertices[i][0])+
      (wy-vertices[i][1])*(wy-vertices[i][1]);
    if(tam &lt; tamin){
      tamin=tam;
      verticeCorrente=i;
    }
  }
  tamin=sqrt(tamin);
  if(tamin &gt; 0.5){
    mudaCurva=0;
  }
}

void mouse(int button, int state, int x, int y){
  switch (button) {
  case GLUT_LEFT_BUTTON:
    if (state == GLUT_DOWN) {
      yreal = matrizViewport[3] - (GLint) y - 1;
      gluUnProject ((GLdouble) x, (GLdouble) yreal, 0.0,
		    matrizModelview, matrizProjecao, matrizViewport,
		    &amp;wx, &amp;wy, &amp;wz);
      mudaCurva=1;
      proximidade();
    }
    if (state == GLUT_UP) {
      mudaCurva=0;
    }
    break;
  }
}

void motion(int x, int y){
  if(mudaCurva){
    yreal = matrizViewport[3] - (GLint) y - 1;
    gluUnProject ((GLdouble) x, (GLdouble) yreal, 0.0,
		  matrizModelview, matrizProjecao, matrizViewport,
		  &amp;wx, &amp;wy, &amp;wz);
    vertices[verticeCorrente][0]=wx;
    vertices[verticeCorrente][1]=wy;
    glutPostRedisplay();
  }
}

int main(int argc, char** argv){
  glutInit(&amp;argc, argv);
  glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
  glutInitWindowSize(500, 500);
  glutInitWindowPosition(100, 100);
  glutCreateWindow(argv[0]);
  init();
  glutDisplayFunc(display);
  glutReshapeFunc(reshape);
  glutKeyboardFunc(keyboard);
  glutMotionFunc(motion);
  glutMouseFunc(mouse);
  glutMainLoop();
  return 0;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_imagem_13">6.1.3. Imagem</h4>
<div id="bezier" class="imageblock">
<div class="content">
<img src="ex/6/splines2d1.png" alt="splines2d1">
</div>
<div class="title">Figure 1. Bézier</div>
</div>
<div id="nurbs" class="imageblock">
<div class="content">
<img src="ex/6/splines2d2.png" alt="splines2d2">
</div>
<div class="title">Figure 2. NURBS</div>
</div>
</div>
<div class="sect3">
<h4 id="_comentário_2">6.1.4. Comentário</h4>
<div class="paragraph">
<p>A curva de Bézier é uma curva polinomial expressa como a interpolação linear entre alguns pontos representativos, chamados de pontos de controle. Ela foi desenvolvida em 1962 e seu nome é devido a quem publicou o primeiro trabalho sobre a curva, o francês Pierre Bézier, funcionário da Renault, que a usou para o design de automóveis. Ela foi estruturada a partir do algoritmo de Paul de Casteljau, da Citroën, em 1957, e foi formalizada na década de 60 (WIKIPEDIA).
São curvas suaves, mas muitas vezes aproximam-se a forma desejada, e não descrevendo esta fielmente, como em um circulo de Bézier.</p>
</div>
<div class="paragraph">
<p>A NURBS é mais flexível que Bézier podendo ser mais "nervosa" quando necessário para representar qualquer forma. Ela é altamente difundida em CADs.</p>
</div>
<div class="paragraph">
<p>É importante frizar que os dois tipos de curvas tem o objetivo de facilitar a modelagem e manipulação de curvas.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_splines_nurbs">6.2. Splines Nurbs</h3>
<div class="sect3">
<h4 id="_questão_13">6.2.1. Questão</h4>
<div class="paragraph">
<p>Utilizando o programa splines2d.c como referência, implemente um programa splinesnurbs.c. Quando a tecla u for pressionada, a NURBS deverá ser desenhada utilizando um vetor de nós uniforme. Quando a tecla o for pressionada, a NURBS deverá ser desenhada utilizando um vetor de nós uniforme aberto. Quando a tecla n for pressionada, a NURBS deverá ser desenhada utilizando um vetor de nós não uniforme.</p>
</div>
<div class="ulist">
<div class="title">Arquivos:</div>
<ul>
<li>
<p><a href="ex/6/splines2d.c" target="_blank">splines2d.c</a></p>
</li>
<li>
<p><a href="ex/6/splinesnurbs.c" target="_blank">splinesnurbs.c</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_código_14">6.2.2. Código</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;stdlib.h&gt;
#include &lt;GL/glut.h&gt;
#include &lt;math.h&gt;

GLint nVertices=6;
GLfloat vertices[6][3] = {
  {-4.0,  0.0, 0.0},
  {-4.0, +4.0, 0.0},
  {+4.0, -4.0, 0.0},
  {-4.0, -4.0, 0.0},
  {+4.0, +4.0, 0.0},
  {+4.0,  0.0, 0.0}
};

GLint largura, altura;
GLint mudaCurva=0;
GLint verticeCorrente=0;

GLfloat esquerda=-5;
GLfloat direita =+5;
GLfloat fundo   =-5;
GLfloat topo    =+5;
GLfloat longe   =+5;
GLfloat perto   =-5;

enum {BEZIER, N_UNIFORM, N_OPEN, N_NOT_UNIFORM};
GLint spline;
GLUnurbsObj *nc;
GLfloat uniformKnots[10]={0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0};
GLfloat openKnots[10]={0.0, 0.0, 0.0, 0.0, 1.0, 2.0, 3.0, 3.0, 3.0, 3.0};
GLfloat notUniformKnots[10]={0.0, 1.0, 5.0, 10.0, 30.0, 32.0, 33.0, 43.0, 73.0, 103.0};
GLint nNos=10;

GLint matrizViewport[4];
GLdouble matrizModelview[16], matrizProjecao[16];
GLint yreal;  /*  posicao da coordenada y no OpenGL */
GLdouble wx, wy, wz;  /*  coordenadas no mundo real: x, y, z  */

void display(void){
  int i;
  glClear(GL_COLOR_BUFFER_BIT);
  switch(spline){
  case BEZIER:
    glMap1f(GL_MAP1_VERTEX_3, 0.0, 1.0, 3, nVertices, &amp;vertices[0][0]);
    glBegin(GL_LINE_STRIP);
    for (i = 0; i &lt;= 30; i++){
      glEvalCoord1f((GLfloat) i/30.0);
    }
    glEnd();
    break;
  case N_UNIFORM:
    gluBeginCurve(nc);
    gluNurbsCurve(nc, nNos, uniformKnots, 3, &amp;vertices[0][0], 4, GL_MAP1_VERTEX_3);
    gluEndCurve(nc);
    break;
  case N_OPEN:
    gluBeginCurve(nc);
    gluNurbsCurve(nc, nNos, openKnots, 3, &amp;vertices[0][0], 4, GL_MAP1_VERTEX_3);
    gluEndCurve(nc);
    break;
  case N_NOT_UNIFORM:
    gluBeginCurve(nc);
    gluNurbsCurve(nc, nNos, notUniformKnots, 3, &amp;vertices[0][0], 4, GL_MAP1_VERTEX_3);
    gluEndCurve(nc);
    break;
  }
  glPointSize(5.0);
  glColor3f(1.0, 1.0, 0.0);
  glBegin(GL_LINE_STRIP);
  for (i = 0; i &lt; nVertices; i++)
    glVertex3fv(&amp;vertices[i][0]);
  glEnd();
  glColor3f(1.0, 0.0, 0.0);
  glBegin(GL_POINTS);
  for (i = 0; i &lt; nVertices; i++)
    glVertex3fv(&amp;vertices[i][0]);
  glEnd();
  glColor3f(1.0, 1.0, 1.0);
  glFlush();
  glutSwapBuffers();
}

void init(void){
  glClearColor(0.0, 0.0, 0.0, 0.0);
  spline=BEZIER;
  nc= gluNewNurbsRenderer();
  gluNurbsProperty(nc, GLU_SAMPLING_TOLERANCE, 5.0);
  glEnable(GL_MAP1_VERTEX_3);
  display();
}

void reshape(int w, int h)
{
  glViewport(0, 0, (GLsizei) w, (GLsizei) h);
  glMatrixMode(GL_PROJECTION);
  largura=w;
  altura=h;
  glLoadIdentity();
  glOrtho(esquerda,direita, fundo, topo, perto, longe);
  glMatrixMode(GL_MODELVIEW);
  glGetIntegerv(GL_VIEWPORT, matrizViewport);
  glGetDoublev(GL_MODELVIEW_MATRIX, matrizModelview);
  glGetDoublev(GL_PROJECTION_MATRIX, matrizProjecao);
  glLoadIdentity();
  glutSwapBuffers();
}

/* ARGSUSED1 */
void keyboard(unsigned char key, int x, int y)
{
  switch (key) {
  case 'b':
    spline = BEZIER;
    break;
  case 'u':
    spline = N_UNIFORM;
    break;
  case 'o':
    spline = N_OPEN;
    break;
  case 'n':
    spline = N_NOT_UNIFORM;
    break;
  case 27:
    exit(0);
    break;
  }
  glutPostRedisplay();
}

void proximidade(){
  int i;
  double tam=0, tamin=32000;
  verticeCorrente=0;
  for(i=0; i&lt;nVertices; i++){
    tam = (wx-vertices[i][0])*(wx-vertices[i][0])+
      (wy-vertices[i][1])*(wy-vertices[i][1]);
    if(tam &lt; tamin){
      tamin=tam;
      verticeCorrente=i;
    }
  }
  tamin=sqrt(tamin);
  if(tamin &gt; 0.5){
    mudaCurva=0;
  }
}

void mouse(int button, int state, int x, int y){
  switch (button) {
  case GLUT_LEFT_BUTTON:
    if (state == GLUT_DOWN) {
      yreal = matrizViewport[3] - (GLint) y - 1;
      gluUnProject ((GLdouble) x, (GLdouble) yreal, 0.0,
        matrizModelview, matrizProjecao, matrizViewport,
        &amp;wx, &amp;wy, &amp;wz);
      mudaCurva=1;
      proximidade();
    }
    if (state == GLUT_UP) {
      mudaCurva=0;
    }
    break;
  }
}

void motion(int x, int y){
  if(mudaCurva){
    yreal = matrizViewport[3] - (GLint) y - 1;
    gluUnProject ((GLdouble) x, (GLdouble) yreal, 0.0,
      matrizModelview, matrizProjecao, matrizViewport,
      &amp;wx, &amp;wy, &amp;wz);
    vertices[verticeCorrente][0]=wx;
    vertices[verticeCorrente][1]=wy;
    glutPostRedisplay();
  }
}

int main(int argc, char** argv){
  glutInit(&amp;argc, argv);
  glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
  glutInitWindowSize(500, 500);
  glutInitWindowPosition(100, 100);
  glutCreateWindow(argv[0]);
  init();
  glutDisplayFunc(display);
  glutReshapeFunc(reshape);
  glutKeyboardFunc(keyboard);
  glutMotionFunc(motion);
  glutMouseFunc(mouse);
  glutMainLoop();
  return 0;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_imagem_14">6.2.3. Imagem</h4>
<div class="imageblock">
<div class="content">
<img src="ex/6/splinesnurbs1.png" alt="splinesnurbs1">
</div>
<div class="title">Figure 3. Uniforme</div>
</div>
<div class="imageblock">
<div class="content">
<img src="ex/6/splinesnurbs2.png" alt="splinesnurbs2">
</div>
<div class="title">Figure 4. Aberta</div>
</div>
<div class="imageblock">
<div class="content">
<img src="ex/6/splinesnurbs3.png" alt="splinesnurbs3">
</div>
<div class="title">Figure 5. Não uniforme</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ordem_splines_nurbs">6.3. Ordem Splines Nurbs</h3>
<div class="sect3">
<h4 id="_questão_14">6.3.1. Questão</h4>
<div class="paragraph">
<p>Qual a influência do vetor de nós foi utilizado sobre o comportamento das curvas tipo NURBS? Comente o resultado que obteve para curvas de ordens 3 e 5.</p>
</div>
<div class="ulist">
<div class="title">Arquivos:</div>
<ul>
<li>
<p><a href="ex/6/splines2d.c" target="_blank">splines2d.c</a></p>
</li>
<li>
<p><a href="ex/6/splinesnurbsordem.c" target="_blank">splinesnurbsordem.c</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_código_15">6.3.2. Código</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;stdlib.h&gt;
#include &lt;GL/glut.h&gt;
#include &lt;math.h&gt;

GLint nVertices=6;
GLfloat vertices[6][3] = {
  {-4.0,  0.0, 0.0},
  {-4.0, +4.0, 0.0},
  {+4.0, -4.0, 0.0},
  {-4.0, -4.0, 0.0},
  {+4.0, +4.0, 0.0},
  {+4.0,  0.0, 0.0}
};

GLint largura, altura;
GLint mudaCurva=0;
GLint verticeCorrente=0;

GLfloat esquerda=-5;
GLfloat direita =+5;
GLfloat fundo   =-5;
GLfloat topo    =+5;
GLfloat longe   =+5;
GLfloat perto   =-5;

enum {BEZIER, NURBS, N_UNIFORM, N_OPEN, N_NOT_UNIFORM};
GLint spline;
GLUnurbsObj *nc;

//ORDEM

GLint ORDEM=3;
GLint nNos=nVertices+ORDEM;
const int nknots = 9;
GLfloat uniformKnots[nknots]   ={0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0};
GLfloat openKnots[nknots]      ={0.0, 0.0, 0.0, 1.0, 2.0, 3.0, 4.0, 4.0, 4.0};
GLfloat notUniformKnots[nknots]={0.0, 1.0, 5.0, 10.0, 30.0, 32.0, 33.0, 43.0, 73.0};

/*GLint ORDEM=4;
GLint nNos=nVertices+ORDEM;
const int nknots = 10;
GLfloat uniformKnots[nknots]   ={0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0};
GLfloat openKnots[nknots]      ={0.0, 0.0, 0.0, 0.0, 1.0, 2.0, 3.0, 3.0, 3.0, 3.0};
GLfloat notUniformKnots[nknots]={0.0, 1.0, 5.0, 10.0, 30.0, 32.0, 33.0, 43.0, 73.0, 103.0};

GLint ORDEM=5;
GLint nNos=nVertices+ORDEM;
const int nknots = 11;
GLfloat uniformKnots[nknots]   ={0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0};
GLfloat openKnots[nknots]      ={0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 2.0, 2.0, 2.0, 2.0, 2.0};
GLfloat notUniformKnots[nknots]={0.0, 1.0, 2.0, 5.0, 10.0, 30.0, 32.0, 33.0, 43.0, 73.0, 103.0};*/

GLint matrizViewport[4];
GLdouble matrizModelview[16], matrizProjecao[16];
GLint yreal;  /*  posicao da coordenada y no OpenGL */
GLdouble wx, wy, wz;  /*  coordenadas no mundo real: x, y, z  */

/*
void gluNurbsCurve( GLUnurbsObj *nobj, GLint nknots, GLfloat *knot, GLint stride,
                    GLfloat *ctlarray, GLint order, GLenum type )
gluNurbsCurve(nc, nNos, uniformKnots, 3, &amp;vertices[0][0], ORDEM, GL_MAP1_VERTEX_3);

-PARAMETERS
nobj
  Specifies the NURBS object (created with gluNewNurbsRenderer).

nknots
  Specifies the number of knots in knot. nknots equals the number
  of control points plus the order.

knot
  Specifies an array of nknots nondecreasing knot values.

stride
  Specifies the offset (as a number of single-precision floating-point
  values) between successive curve control points.

ctlarray
  Specifies a pointer to an array of control points. The coordinates
  must agree with type, specified below.

order
  Specifies the order of the NURBS curve. order equals degree + 1,
  hence a cubic curve has an order of 4.

type
  Specifies the type of the curve. If this curve is defined within
  a gluBeginCurve/gluEndCurve pair, then the type can be any of the
  valid one-dimensional evaluator types (such as GL_MAP1_VERTEX_3 or
  GL_MAP1_COLOR_4). Between a gluBeginTrim/gluEndTrim pair, the only
  valid types are GLU_MAP1_TRIM_2 and GLU_MAP1_TRIM_3.
*/
void display(void){
  int i;
  glClear(GL_COLOR_BUFFER_BIT);
  switch(spline){
  case BEZIER:
    glMap1f(GL_MAP1_VERTEX_3, 0.0, 1.0, 3, nVertices, &amp;vertices[0][0]);
    glBegin(GL_LINE_STRIP);
    for (i = 0; i &lt;= 30; i++){
      glEvalCoord1f((GLfloat) i/30.0);
    }
    glEnd();
    break;
  case N_UNIFORM:
    gluBeginCurve(nc);
    gluNurbsCurve(nc, nNos, uniformKnots, 3, &amp;vertices[0][0], ORDEM, GL_MAP1_VERTEX_3);
    gluEndCurve(nc);
    break;
  case N_OPEN:
    gluBeginCurve(nc);
    gluNurbsCurve(nc, nNos, openKnots, 3, &amp;vertices[0][0], ORDEM, GL_MAP1_VERTEX_3);
    gluEndCurve(nc);
    break;
  case N_NOT_UNIFORM:
    gluBeginCurve(nc);
    gluNurbsCurve(nc, nNos, notUniformKnots, 3, &amp;vertices[0][0], ORDEM, GL_MAP1_VERTEX_3);
    gluEndCurve(nc);
    break;
  }
  glPointSize(5.0);
  glColor3f(1.0, 1.0, 0.0);
  glBegin(GL_LINE_STRIP);
  for (i = 0; i &lt; nVertices; i++)
    glVertex3fv(&amp;vertices[i][0]);
  glEnd();
  glColor3f(1.0, 0.0, 0.0);
  glBegin(GL_POINTS);
  for (i = 0; i &lt; nVertices; i++)
    glVertex3fv(&amp;vertices[i][0]);
  glEnd();
  glColor3f(1.0, 1.0, 1.0);
  glFlush();
  glutSwapBuffers();
}

void init(void){
  glClearColor(0.0, 0.0, 0.0, 0.0);
  spline=BEZIER;
  nc= gluNewNurbsRenderer();
  // gluNurbsProperty(nc, GLU_SAMPLING_TOLERANCE, 5.0);
  glEnable(GL_MAP1_VERTEX_3);
  display();
}

void reshape(int w, int h)
{
  glViewport(0, 0, (GLsizei) w, (GLsizei) h);
  glMatrixMode(GL_PROJECTION);
  largura=w;
  altura=h;
  glLoadIdentity();
  glOrtho(esquerda,direita, fundo, topo, perto, longe);
  glMatrixMode(GL_MODELVIEW);
  glGetIntegerv(GL_VIEWPORT, matrizViewport);
  glGetDoublev(GL_MODELVIEW_MATRIX, matrizModelview);
  glGetDoublev(GL_PROJECTION_MATRIX, matrizProjecao);
  glLoadIdentity();
  glutSwapBuffers();
}

/* ARGSUSED1 */
void keyboard(unsigned char key, int x, int y)
{
  switch (key) {
  case 'b':
    spline = BEZIER;
    break;
  case 'u':
    spline = N_UNIFORM;
    break;
  case 'o':
    spline = N_OPEN;
    break;
  case 'n':
    spline = N_NOT_UNIFORM;
    break;
  case 27:
    exit(0);
    break;
  }
  glutPostRedisplay();
}

void proximidade(){
  int i;
  double tam=0, tamin=32000;
  verticeCorrente=0;
  for(i=0; i&lt;nVertices; i++){
    tam = (wx-vertices[i][0])*(wx-vertices[i][0])+
      (wy-vertices[i][1])*(wy-vertices[i][1]);
    if(tam &lt; tamin){
      tamin=tam;
      verticeCorrente=i;
    }
  }
  tamin=sqrt(tamin);
  if(tamin &gt; 0.5){
    mudaCurva=0;
  }
}

void mouse(int button, int state, int x, int y){
  switch (button) {
  case GLUT_LEFT_BUTTON:
    if (state == GLUT_DOWN) {
      yreal = matrizViewport[3] - (GLint) y - 1;
      gluUnProject ((GLdouble) x, (GLdouble) yreal, 0.0,
        matrizModelview, matrizProjecao, matrizViewport,
        &amp;wx, &amp;wy, &amp;wz);
      mudaCurva=1;
      proximidade();
    }
    if (state == GLUT_UP) {
      mudaCurva=0;
    }
    break;
  }
}

void motion(int x, int y){
  if(mudaCurva){
    yreal = matrizViewport[3] - (GLint) y - 1;
    gluUnProject ((GLdouble) x, (GLdouble) yreal, 0.0,
      matrizModelview, matrizProjecao, matrizViewport,
      &amp;wx, &amp;wy, &amp;wz);
    vertices[verticeCorrente][0]=wx;
    vertices[verticeCorrente][1]=wy;
    glutPostRedisplay();
  }
}

int main(int argc, char** argv){
  glutInit(&amp;argc, argv);
  glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
  glutInitWindowSize(500, 500);
  glutInitWindowPosition(100, 100);
  glutCreateWindow(argv[0]);
  init();
  glutDisplayFunc(display);
  glutReshapeFunc(reshape);
  glutKeyboardFunc(keyboard);
  glutMotionFunc(motion);
  glutMouseFunc(mouse);
  glutMainLoop();
  return 0;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_imagem_15">6.3.3. Imagem</h4>
<div class="imageblock">
<div class="content">
<img src="ex/6/splinesnurbsordem1.png" alt="splinesnurbsordem1">
</div>
<div class="title">Figure 6. Uniforme Ordem 3</div>
</div>
<div class="imageblock">
<div class="content">
<img src="ex/6/splinesnurbsordem2.png" alt="splinesnurbsordem2">
</div>
<div class="title">Figure 7. Uniforme Ordem 4</div>
</div>
<div class="imageblock">
<div class="content">
<img src="ex/6/splinesnurbsordem3.png" alt="splinesnurbsordem3">
</div>
<div class="title">Figure 8. Uniforme Ordem 5</div>
</div>
</div>
<div class="sect3">
<h4 id="_comentário_3">6.3.4. Comentário</h4>
<div class="paragraph">
<p>Quanto maior a ordem, menos flexível e suave a curva fica. O resultado fica evidente nas imagens acima.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_comparação">6.4. Comparação</h3>
<div class="sect3">
<h4 id="_questão_15">6.4.1. Questão</h4>
<div class="paragraph">
<p>Compare curvas de Beziér com NURBS considerando ordens iguais para ambas as curvas.</p>
</div>
</div>
<div class="sect3">
<h4 id="_comentário_4">6.4.2. Comentário</h4>
<div class="paragraph">
<p>É possível verificar que <a href="#bezier">Bézier</a> é mais suave, uma interpolação do ponto inicial ao final sofrendo interferencia dos vertices de controle. E <a href="#nurbs">NURBS</a> tem uma influencia forte dos vertices controle sendo muito mais maleável.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_superfícies_no_espaço">7. Superfícies no espaço</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_spline_inter">7.1. Spline Inter</h3>
<div class="sect3">
<h4 id="_questão_16">7.1.1. Questão</h4>
<div class="paragraph">
<p>Utilizando as técnicas de seleção de objetos apresentadas no Capítulo [superficies-espaco], implemente um programa splineinter.c que proporcione um processo de modelagem interativa para este exemplo. Quando pressionar o botão esquerdo do mouse, o usuário deverá poder movimentar os pontos da malha de controle, podendo assim controlar livremente a forma da superfície.</p>
</div>
<div class="ulist">
<div class="title">Arquivos:</div>
<ul>
<li>
<p><a href="ex/7/splines3d.c" target="_blank">splines3d.c</a></p>
</li>
<li>
<p><a href="ex/7/splineinter.c" target="_blank">splineinter.c</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_código_16">7.1.2. Código</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;GL/glut.h&gt;

// To work better with vectors
#define X 0
#define Y 1
#define Z 2
#define MINDISTANCE 0.5
#define INTLIMIT 32000

GLint eixox, eixoy, eixoz;

GLint nVertices = 4;
GLfloat vertices[4][4][3];

GLint largura, altura;

GLint mudaCurva = 0;
GLint verticeCorrente = 0;

enum {BEZIER, NURBS};
GLint spline;
GLUnurbsObj *nc;
GLfloat nos[8] = {0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0};
GLint nNos = 8;

GLint matrizViewport[4];
GLdouble matrizModelview[16], matrizProjecao[16];
GLint yreal;  /*  posição da coordenada y no OpenGL */
GLdouble wx, wy, wz;  /*  coordenadas no mundo real: x, y, z  */
GLdouble winx, winy, winz;  /*  coordenadas na janela: x, y, z  */
GLdouble clickPos[3];
GLdouble pmin[3]; // armazena o valor minimo dos p's
GLdouble w1[3], w2[3]; // ponto inicial e ponto final
GLint vc[2] = {0, 0}; // vertice selecionado para movimentacao

void gera_superficie(void) {
  int i, j;
  for (i = 0; i &lt; 4; i++) {
    for (j = 0; j &lt; 4; j++) {
      vertices[i][j][0] = 2.0 * ((GLfloat)i - 1.5);
      vertices[i][j][1] = 2.0 * ((GLfloat)j - 1.5);

      if ( (i == 1 || i == 2) &amp;&amp; (j == 1 || j == 2))
        vertices[i][j][2] = 7.0;
      else
        vertices[i][j][2] = -3.0;
    }
  }
}
void display(void) {
  int i, j;

  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

  glPushMatrix();
  glRotatef(eixox, 1 , 0 , 0);
  glRotatef(eixoy, 0 , 1 , 0);
  glRotatef(eixoz, 0 , 0 , 1);
  glScalef(0.25, 0.25, 0.25);

  glGetIntegerv(GL_VIEWPORT, matrizViewport);
  glGetDoublev(GL_MODELVIEW_MATRIX, matrizModelview);
  glGetDoublev(GL_PROJECTION_MATRIX, matrizProjecao);

  glDisable(GL_LIGHTING);
  glPushMatrix();
  glTranslatef(-5, -5, -5);
  glColor3f(1, 1, 1);
  glBegin(GL_LINES);
  glVertex3f(0, 0, 0);  glVertex3f(1, 0, 0);
  glEnd();
  glRasterPos3f(1.5, 0, 0);
  glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_10, 'x');

  glBegin(GL_LINES);
  glVertex3f(0, 0, 0);  glVertex3f(0, 1, 0);
  glEnd();
  glRasterPos3f(0, 1.5, 0);
  glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_10, 'y');

  glBegin(GL_LINES);
  glVertex3f(0, 0, 0);  glVertex3f(0, 0, 1);
  glEnd();
  glRasterPos3f(0, 0, 1.5);
  glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_10, 'z');

  glPopMatrix();
  glEnable(GL_LIGHTING);

  switch (spline) {
  case BEZIER:
    glMap2f(GL_MAP2_VERTEX_3, 0.0, 1.0, 3, 4, 0, 1, 3 * nVertices, 4, &amp;vertices[0][0][0]);
    glEnable(GL_AUTO_NORMAL);
    glMapGrid2f(20, 0, 1.0, 20, 0, 1.0);
    glEvalMesh2(GL_FILL, 0, 20, 0, 20);
    break;
  case NURBS:
    gluBeginSurface(nc);
    gluNurbsSurface(nc, nNos, nos, nNos, nos, 4 * 3, 3, &amp;vertices[0][0][0], 4, 4, GL_MAP2_VERTEX_3);
    gluEndSurface(nc);
    break;
  }
  glPointSize(5.0);
  glColor3f(1.0, 0.0, 0.0);
  glDisable(GL_LIGHTING);
  glBegin(GL_POINTS);
  for (i = 0; i &lt; 4; i++) {
    for (j = 0; j &lt; 4; j++) {
      glVertex3fv(&amp;vertices[i][j][0]);
    }
  }
  glEnable(GL_LIGHTING);
  glEnd();

  glPopMatrix();
  glFlush();

  glutSwapBuffers();
}

void init(void) {
  GLfloat mat_diffuse[] = { 0.7, 0.7, 0.7, 1.0 };
  GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };
  GLfloat mat_shininess[] = { 100.0 };

  glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
  glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
  glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);

  glEnable(GL_LIGHTING);
  glEnable(GL_LIGHT0);

  glEnable(GL_DEPTH_TEST);
  glEnable(GL_AUTO_NORMAL);
  glEnable(GL_NORMALIZE);

  gera_superficie();

  nc = gluNewNurbsRenderer();
  gluNurbsProperty(nc, GLU_SAMPLING_TOLERANCE, 5.0);
  gluNurbsProperty(nc, GLU_DISPLAY_MODE, GLU_FILL);

  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  glTranslatef (0.0, 0.0, -5.0);

  spline = NURBS;
  glClearColor(0.0, 0.0, 0.0, 0.0);
  glShadeModel(GL_SMOOTH);
  glEnable(GL_MAP2_VERTEX_3);
  display();
}

void reshape(int w, int h) {
  glViewport(0, 0, w, h);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  gluPerspective (45.0, (GLdouble)w / (GLdouble)h, 3.0, 8.0);
  glMatrixMode(GL_MODELVIEW);
}

/* ARGSUSED1 */
void keyboard(unsigned char key, int x, int y) {
  switch (key) {
  case 'x':
    eixox = (eixox + 5) % 360;
    glutPostRedisplay();
    break;
  case 'y':
    eixoy = (eixoy + 5) % 360;
    glutPostRedisplay();
    break;
  case 'z':
    eixoz = (eixoz + 5) % 360;
    glutPostRedisplay();
    break;
  case 'X':
    eixox = (eixox - 5) % 360;
    glutPostRedisplay();
    break;
  case 'Y':
    eixoy = (eixoy - 5) % 360;
    glutPostRedisplay();
    break;
  case 'Z':
    eixoz = (eixoz - 5) % 360;
    glutPostRedisplay();
    break;
  case 'b':
    spline = BEZIER;
    glutPostRedisplay();
    break;
  case 'n':
    spline = NURBS;
    glutPostRedisplay();
    break;
  case 27:
    exit(0);
    break;
  }
}

void proximidade() {
  int i, j;
  double tam = 0, tamin = INTLIMIT;
  double dx, dy, dz, px, py, pz;
  double piv, pir;

  // Y = V.V
  piv = clickPos[X] * clickPos[X] + clickPos[Y] * clickPos[Y] + clickPos[Z] * clickPos[Z];

  for (i = 0; i &lt; 4; i++) {
    for (j = 0; j &lt; 4; j++) {

      // Z = (R - Po)
      dx = vertices[i][j][0] - w1[X];
      dy = vertices[i][j][1] - w1[Y];
      dz = vertices[i][j][2] - w1[Z];

      // X = Z.V
      pir = dx * clickPos[X] + dy * clickPos[Y] + dz * clickPos[Z];

      // Po + (X/Y).V
      px = w1[X] + pir / piv * clickPos[X];
      py = w1[Y] + pir / piv * clickPos[Y];
      pz = w1[Z] + pir / piv * clickPos[Z];

      // T = (xf-xi)^2 + (yf-yi)^2
      tam = (px - vertices[i][j][0]) * (px - vertices[i][j][0]) +
            (py - vertices[i][j][1]) * (py - vertices[i][j][1]) +
            (pz - vertices[i][j][2]) * (pz - vertices[i][j][2]);

      if ((tam &lt; tamin) &amp;&amp; (tam &lt; MINDISTANCE)) {
        tamin = tam;
        vc[X] = i;
        vc[Y] = j;
        pmin[0] = px;
        pmin[1] = py;
        pmin[2] = pz;
      }
    }
  }
  if (tamin &lt; MINDISTANCE) {
    gluProject(pmin[0], pmin[1], pmin[2],
               matrizModelview, matrizProjecao, matrizViewport,
               &amp;winx, &amp;winy, &amp;winz);
    mudaCurva = 1;
  }
  else {
    mudaCurva = 0;
  }
}

void mouse(int button, int state, int x, int y) {
  if (button == GLUT_LEFT_BUTTON &amp;&amp; state == GLUT_DOWN) {

    yreal = matrizViewport[3] - (GLint) y - 1;

    gluUnProject ((GLdouble) x, (GLdouble) yreal, -1.0,
                  matrizModelview, matrizProjecao, matrizViewport,
                  &amp;w1[X], &amp;w1[Y], &amp;w1[Z]);

    gluUnProject ((GLdouble) x, (GLdouble) yreal, 1.0,
                  matrizModelview, matrizProjecao, matrizViewport,
                  &amp;w2[X], &amp;w2[Y], &amp;w2[Z]);

    clickPos[X] = w2[X] - w1[X];
    clickPos[Y] = w2[Y] - w1[Y];
    clickPos[Z] = w2[Z] - w1[Z];
    proximidade();

    glutPostRedisplay();
  } else {
    mudaCurva = 0;
  }
}

void motion(int x, int y) {
  // quando tiver clicado em ponto de controle
  if (mudaCurva) {
    // convert y para coordenadas de mundo
    yreal = matrizViewport[3] - (GLint) y - 1;
    // recupera a posicao do x, y, z do mouse
    gluUnProject((GLdouble) x, (GLdouble) yreal, winz,
                 matrizModelview, matrizProjecao, matrizViewport,
                 &amp;wx, &amp;wy, &amp;wz);
    // altera a posicao do vertice de controle
    vertices[vc[X]][vc[Y]][0] = wx;
    vertices[vc[X]][vc[Y]][1] = wy;
    vertices[vc[X]][vc[Y]][2] = wz;
    //redesenha
    glutPostRedisplay();
  }
}

int main(int argc, char** argv) {
  glutInit(&amp;argc, argv);
  glutInitDisplayMode(GLUT_DEPTH | GLUT_DOUBLE | GLUT_RGB);
  glutInitWindowSize(500, 500);
  glutInitWindowPosition(100, 100);
  glutCreateWindow(argv[0]);
  init();
  glutDisplayFunc(display);
  glutReshapeFunc(reshape);
  glutKeyboardFunc(keyboard);
  glutMotionFunc(motion);
  glutMouseFunc(mouse);
  glutMainLoop();
  return 0;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_imagem_16">7.1.3. Imagem</h4>
<div class="imageblock">
<div class="content">
<img src="ex/7/splineinter1.png" alt="splineinter1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="ex/7/splineinter2.png" alt="splineinter2">
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_modelagem_de_sólidos">8. Modelagem de Sólidos</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_super_jato">8.1. Super Jato</h3>
<div class="sect3">
<h4 id="_questão_17">8.1.1. Questão</h4>
<div class="paragraph">
<p>Utilizando o programa exemplos/jato.c como referência, implemente um programa superjato.c. Caso você ainda não tenha notado, o avião a jato deste exemplo não possui uma turbina. Faça-o mais interessante, projetando essa turbina e acoplando-a à parte traseira do jato no seu novo programa. O modelo da turbina fica a seu gosto. Acrescente também dois mísseis sob as asas.</p>
</div>
<div class="ulist">
<div class="title">Arquivos:</div>
<ul>
<li>
<p><a href="ex/8/jato.c" target="_blank">jato.c</a></p>
</li>
<li>
<p><a href="ex/8/png_texture.h" target="_blank">png_texture.h</a></p>
</li>
<li>
<p><a href="ex/8/camuflagem.png" target="_blank">camuflagem.png</a></p>
</li>
<li>
<p><a href="ex/8/montanhas.png" target="_blank">montanhas.png</a></p>
</li>
<li>
<p><a href="ex/8/flame2.png" target="_blank">flame2.png</a></p>
</li>
<li>
<p><a href="ex/8/superjato.c" target="_blank">superjato.c</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_código_17">8.1.2. Código</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;GL/glut.h&gt;
#include "png_texture.h"

#define PI 3.1415

#define COORD_TEXTURA_PLANO 1.0
#define COORD_TEXTURA_AVIAO 1.0
#define COR_DO_PLANO 0.52,0.52,0.78,1.0
#define COR_DO_AVIAO 0.3,0.52,0.18,1.0
#define COR_DA_LOGO 0.7,0.52,0.58,1.0
#define COR_DA_TURBINA 0.24,0.24,0.24,1.0
#define TEXTURA_DO_PLANO "montanhas.png"
#define TEXTURA_DO_AVIAO "camuflagem.png"
#define TEXTURA_DA_CHAMA "flame2.png"


GLint WIDTH =800;
GLint HEIGHT=600;

GLfloat obs[3]={0.0,7.0,0.0};
GLfloat look[3]={0.0,3.0,0.0};
GLuint  textura_plano;
GLuint  textura_aviao;
GLuint  textura_chama;

GLshort texturas=1;
GLshort flame_is_on=1;
GLfloat tetaxz=0;
GLfloat raioxz=6;
GLuint  jato;

GLfloat ctp[4][2]={
  {-COORD_TEXTURA_PLANO,-COORD_TEXTURA_PLANO},
  {+COORD_TEXTURA_PLANO,-COORD_TEXTURA_PLANO},
  {+COORD_TEXTURA_PLANO,+COORD_TEXTURA_PLANO},
  {-COORD_TEXTURA_PLANO,+COORD_TEXTURA_PLANO}
};

GLfloat cta[4][2]={
  {-COORD_TEXTURA_AVIAO,-COORD_TEXTURA_AVIAO},
  {+COORD_TEXTURA_AVIAO,-COORD_TEXTURA_AVIAO},
  {+COORD_TEXTURA_AVIAO,+COORD_TEXTURA_AVIAO},
  {-COORD_TEXTURA_AVIAO,+COORD_TEXTURA_AVIAO}
};

GLfloat ctl[4][2]={
  {0,0},
  {1,0},
  {1,1},
  {0,1}
};

GLfloat asa[][3]={
  {-4.0,0.0,0.0},
  {+4.0,0.0,0.0},
  {0.0,0.0,3.0}
};

GLfloat cauda[][3]={
  {0.0,0.0,0.0},
  {0.0,2.0,-1.0},
  {0.0,2.0,0.0},
  {0.0,0.0,2.0}
};

void reshape(int width, int height){
  WIDTH=width;
  HEIGHT=height;
  glViewport(0,0,(GLint)width,(GLint)height);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  gluPerspective(70.0,width/(float)height,0.1,30.0);
  glMatrixMode(GL_MODELVIEW);
}

void compoe_jato(void){
  GLUquadricObj *quadric;

  /* inicia a composicao do jato */
  jato = glGenLists(1);
  glNewList(jato, GL_COMPILE);

  /* asas */
  glBegin(GL_TRIANGLES);
  glTexCoord2fv(cta[0]); glVertex3fv(asa[0]);
  glTexCoord2fv(cta[1]); glVertex3fv(asa[1]);
  glTexCoord2fv(cta[3]); glVertex3fv(asa[2]);
  glEnd();

  /*missil1*/
  glPushMatrix();
  //posiciona
  glTranslatef(-2, -0.11, 1);
  quadric = gluNewQuadric();
  gluQuadricTexture(quadric, GL_TRUE);
  //bico
  gluCylinder(quadric, 0.1, 0.0, 0.4, 8, 1);
  //corpo
  glTranslatef(0, 0, -0.8);
  gluCylinder(quadric, 0.1, 0.1, 0.8, 8, 1);
  //cauda
  glTranslatef(0, 0, -0.05);
  gluCylinder(quadric, 0.0, 0.1, 0.05, 8, 1);
  glPopMatrix();

  /*missil2*/
  glPushMatrix();
  //posiciona
  glTranslatef(2, -0.11, 1);
  quadric = gluNewQuadric();
  gluQuadricTexture(quadric, GL_TRUE);
  //bico
  gluCylinder(quadric, 0.1, 0.0, 0.4, 8, 1);
  //corpo
  glTranslatef(0, 0, -0.8);
  gluCylinder(quadric, 0.1, 0.1, 0.8, 8, 1);
  //cauda
  glTranslatef(0, 0, -0.05);
  gluCylinder(quadric, 0.0, 0.1, 0.05, 8, 1);
  glPopMatrix();

  /* corpo */
  quadric = gluNewQuadric();
  gluQuadricTexture(quadric, GL_TRUE);
  gluCylinder(quadric, 0.5, 0.5, 4, 12, 3);

  //guarda para turbina
  glPushMatrix();

  /* nariz */
  quadric = gluNewQuadric();
  gluQuadricTexture(quadric, GL_TRUE);
  glPushMatrix();
  glTranslatef(0,0,4);
  gluCylinder(quadric, 0.5, 0.0, 1.5, 12, 3);
  glPopMatrix();

  /* cauda */
  glBegin(GL_POLYGON);
  glTexCoord2fv(cta[0]); glVertex3fv(cauda[0]);
  glTexCoord2fv(cta[1]); glVertex3fv(cauda[1]);
  glTexCoord2fv(cta[2]); glVertex3fv(cauda[2]);
  glTexCoord2fv(cta[3]); glVertex3fv(cauda[3]);
  glEnd();

  /* turbina */
  //retorna mat para turbina
  glPopMatrix();
  glPushMatrix();
  glTranslatef(0,0,-1);

  quadric = gluNewQuadric();
  if (flame_is_on) {
    printf("%s\n", "isON");
    gluQuadricTexture(quadric, GL_TRUE);
    glBindTexture(GL_TEXTURE_2D,textura_chama);
    glColor4f(1.0,0.0,0.0,0.5);
    gluCylinder(quadric, 0.1, 0.497, 1, 12, 1);
  }

  glTranslatef(0,0,0.4);
  glDisable(GL_TEXTURE_2D);
  if (flame_is_on) {
    glColor4f(1.0,0.0,0.0,1.0);
  } else {
    glColor4f(0.34,0.34,0.34,1.0);
  }
  gluCylinder(quadric, 0, 0.495, 0.6, 12, 1);
  glTranslatef(0,0,0.35);

  glColor4f(COR_DA_TURBINA);
  gluCylinder(quadric, 0.4, 0.5, 0.25, 12, 1);
  glPopMatrix();
  /* end - turbina*/

  /* cabine do piloto */
  glDisable(GL_TEXTURE_2D);
  glTranslatef(0,0.3,3.5);
  glPushMatrix();
  glScalef(0.7,0.7,2.0);
  quadric=gluNewQuadric();
  glColor4f(0.3,0.5,1,0.5);
  gluSphere(quadric,0.5,12,12);
  glPopMatrix();


  /* termina a composicao do jato*/
  glEndList();
}

void display(void){
  glEnable(GL_DEPTH_TEST);

  //glDepthMask(GL_TRUE);
  glClearColor(1.0,1.0,1.0,1.0);
  glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);

  glPushMatrix();

  /* calcula a posicao do observador */
  obs[0]=raioxz*cos(2*PI*tetaxz/360);
  obs[2]=raioxz*sin(2*PI*tetaxz/360);
  gluLookAt(obs[0],obs[1],obs[2],look[0],look[1],look[2],0.0,1.0,0.0);

  /* habilita/desabilita uso de texturas*/
  if(texturas){
    glEnable(GL_TEXTURE_2D);
  }
  else{
    glDisable(GL_TEXTURE_2D);
  }
  glTexEnvf(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_DECAL);

  // grava a transformacao atual
  glPushMatrix();
  //plano texturizado
  glColor4f(COR_DO_PLANO);
  glPolygonMode( GL_FRONT_AND_BACK, GL_FILL );
  glBindTexture(GL_TEXTURE_2D,textura_plano);
  glBegin(GL_QUADS);
  glTexCoord2fv(ctp[0]);  glVertex3f(-10,0,10);
  glTexCoord2fv(ctp[1]);  glVertex3f(10,0,10);
  glTexCoord2fv(ctp[2]);  glVertex3f(10,0,-10);
  glTexCoord2fv(ctp[3]);  glVertex3f(-10,0,-10);
  glEnd();

  //aviao texturizado
  glTranslatef(0.0,2.0,-3.0);
  glColor4f(COR_DO_AVIAO);
  glBindTexture(GL_TEXTURE_2D,textura_aviao);
  glCallList(jato);
  glPopMatrix();
  // volta para a ultima transformacao

  // grava a transformacao atual
  glPushMatrix();
  glPolygonMode( GL_FRONT_AND_BACK, GL_LINE );
  glColor4f(COR_DO_PLANO);
  glBindTexture(GL_TEXTURE_2D,textura_plano);

  glBegin(GL_QUADS);
  glTexCoord2fv(ctp[0]);  glVertex3f(-10,0,10);
  glTexCoord2fv(ctp[1]);  glVertex3f(10,0,10);
  glTexCoord2fv(ctp[2]);  glVertex3f(10,0,-10);
  glTexCoord2fv(ctp[3]);  glVertex3f(-10,0,-10);
  glEnd();
  glTranslatef(0.0,2.0,-3.0);
  glColor4f(COR_DO_AVIAO);
  glBindTexture(GL_TEXTURE_2D,textura_aviao);
  glCallList(jato);
  glPopMatrix();
  // volta para a ultima transformacao

  glPopMatrix();
  glutSwapBuffers();
}


void special(int key, int x, int y){
  switch (key) {
  case GLUT_KEY_UP:
    obs[1]=obs[1]+1;
    glutPostRedisplay();
    break;
  case GLUT_KEY_DOWN:
    obs[1] =obs[1]-1;
    glutPostRedisplay();
    break;
  case GLUT_KEY_LEFT:
    tetaxz=tetaxz+2;
    glutPostRedisplay();
    break;
  case GLUT_KEY_RIGHT:
    tetaxz=tetaxz-2;
    glutPostRedisplay();
    break;
  }
}

void keyboard(unsigned char key, int x, int y){
  switch (key) {
  case 27:
    exit(0);
    break;
  case 't':
    texturas = !texturas;
    glutPostRedisplay();
    break;
  case 'r':
    raioxz=raioxz+1;
    glutPostRedisplay();
    break;
  case 'R':
    raioxz=raioxz-1;
    if(raioxz==0){
      raioxz=1;
    }
    glutPostRedisplay();
    break;
  case 'o':
    flame_is_on = !flame_is_on;
    compoe_jato();
    //printf("%i\n", flame_is_on);
    glutPostRedisplay();
    break;
  }
}

void carregar_texturas(void){
  textura_plano = png_texture_load(TEXTURA_DO_PLANO, NULL, NULL);
  textura_aviao = png_texture_load(TEXTURA_DO_AVIAO, NULL, NULL);
  textura_chama = png_texture_load(TEXTURA_DA_CHAMA, NULL, NULL);
}

void init(){
  glEnable(GL_DEPTH_TEST);

  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
  carregar_texturas();
  compoe_jato();
  //  glShadeModel(GL_FLAT);
  glEnable(GL_TEXTURE_2D);
}

int main(int argc,char **argv){
  glutInitWindowPosition(0,0);
  glutInitWindowSize(WIDTH,HEIGHT);
  glutInit(&amp;argc,argv);
  glutInitDisplayMode(GLUT_RGBA|GLUT_DEPTH|GLUT_DOUBLE|GLUT_ALPHA);

  if(!glutCreateWindow("Avião a jato")) {
    fprintf(stderr,"Error opening a window.\n");
    exit(-1);
  }

  init();

  glutKeyboardFunc(keyboard);
  glutSpecialFunc(special);
  glutDisplayFunc(display);
  glutReshapeFunc(reshape);
  glutMainLoop();

  return(0);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_imagem_17">8.1.3. Imagem</h4>
<div class="imageblock">
<div class="content">
<img src="ex/8/superjato1.png" alt="superjato1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="ex/8/superjato2.png" alt="superjato2">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="ex/8/superjato3.png" alt="superjato3">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="ex/8/superjato4.png" alt="superjato4">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_comentário_5">8.1.4. Comentário</h4>
<div class="paragraph">
<p>Para ligar e desligar a turbina precione a tecla 'o'.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_super_jato_com_logo">8.2. Super Jato com Logo</h3>
<div class="sect3">
<h4 id="_questão_18">8.2.1. Questão</h4>
<div class="paragraph">
<p>Crie um logotipo utilizando um programa de manipulação de imagens de sua preferência. Salve-o no formato Iris RGB e mapeie-o na parte superior da asa, como mostra a Figura Exemplo de logotipo para o superjato.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="ex/8/exemplo.svg" alt="exemplo">
</div>
</div>
<div class="ulist">
<div class="title">Arquivos:</div>
<ul>
<li>
<p><a href="ex/8/superjato.c" target="_blank">superjato.c</a></p>
</li>
<li>
<p><a href="ex/8/png_texture.h" target="_blank">png_texture.h</a></p>
</li>
<li>
<p><a href="ex/8/camuflagem.png" target="_blank">camuflagem.png</a></p>
</li>
<li>
<p><a href="ex/8/montanhas.png" target="_blank">montanhas.png</a></p>
</li>
<li>
<p><a href="ex/8/flame2.png" target="_blank">flame2.png</a></p>
</li>
<li>
<p><a href="ex/8/logo.png" target="_blank">logo.png</a></p>
</li>
<li>
<p><a href="ex/8/superjatologo.c" target="_blank">superjatologo.c</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_código_18">8.2.2. Código</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;GL/glut.h&gt;
#include "png_texture.h"

#define PI 3.1415

#define COORD_TEXTURA_PLANO 1.0
#define COORD_TEXTURA_AVIAO 1.0
#define COR_DO_PLANO 0.52,0.52,0.78,1.0
#define COR_DO_AVIAO 0.3,0.52,0.18,1.0
#define COR_DA_LOGO 0.7,0.52,0.58,1.0
#define COR_DA_TURBINA 0.24,0.24,0.24,1.0
#define TEXTURA_DO_PLANO "montanhas.png"
#define TEXTURA_DO_AVIAO "camuflagem.png"
#define LOGO_DO_AVIAO "logo.png"
#define TEXTURA_DA_CHAMA "flame2.png"


GLint WIDTH =800;
GLint HEIGHT=600;

GLfloat obs[3]={0.0,7.0,0.0};
GLfloat look[3]={0.0,3.0,0.0};
GLuint  textura_plano;
GLuint  textura_aviao;
GLuint  logo_aviao;
GLuint  textura_chama;

GLshort texturas=1;
GLshort flame_is_on=1;
GLfloat tetaxz=0;
GLfloat raioxz=6;
GLuint  jato;

GLfloat ctp[4][2]={
  {-COORD_TEXTURA_PLANO,-COORD_TEXTURA_PLANO},
  {+COORD_TEXTURA_PLANO,-COORD_TEXTURA_PLANO},
  {+COORD_TEXTURA_PLANO,+COORD_TEXTURA_PLANO},
  {-COORD_TEXTURA_PLANO,+COORD_TEXTURA_PLANO}
};

GLfloat cta[4][2]={
  {-COORD_TEXTURA_AVIAO,-COORD_TEXTURA_AVIAO},
  {+COORD_TEXTURA_AVIAO,-COORD_TEXTURA_AVIAO},
  {+COORD_TEXTURA_AVIAO,+COORD_TEXTURA_AVIAO},
  {-COORD_TEXTURA_AVIAO,+COORD_TEXTURA_AVIAO}
};

GLfloat ctl[4][2]={
  {0,0},
  {1,0},
  {1,1},
  {0,1}
};

GLfloat asa[][3]={
  {-4.0,0.0,0.0},
  {+4.0,0.0,0.0},
  {0.0,0.0,3.0}
};

GLfloat cauda[][3]={
  {0.0,0.0,0.0},
  {0.0,2.0,-1.0},
  {0.0,2.0,0.0},
  {0.0,0.0,2.0}
};

GLfloat logo[][3]={
  {0.0,1.0,-0.2},
  {0.0,1.5,-0.2},
  {0.0,1.5,0.3},
  {0.0,1.0,0.3}
};

void reshape(int width, int height){
  WIDTH=width;
  HEIGHT=height;
  glViewport(0,0,(GLint)width,(GLint)height);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  gluPerspective(70.0,width/(float)height,0.1,30.0);
  glMatrixMode(GL_MODELVIEW);
}

void compoe_jato(void){
  GLUquadricObj *quadric;

  /* inicia a composicao do jato */
  jato = glGenLists(1);
  glNewList(jato, GL_COMPILE);

  /* asas */
  glBegin(GL_TRIANGLES);
  glTexCoord2fv(cta[0]); glVertex3fv(asa[0]);
  glTexCoord2fv(cta[1]); glVertex3fv(asa[1]);
  glTexCoord2fv(cta[3]); glVertex3fv(asa[2]);
  glEnd();

  /*missil1*/
  glPushMatrix();
  //posiciona
  glTranslatef(-2, -0.11, 1);
  quadric = gluNewQuadric();
  gluQuadricTexture(quadric, GL_TRUE);
  //bico
  gluCylinder(quadric, 0.1, 0.0, 0.4, 8, 1);
  //corpo
  glTranslatef(0, 0, -0.8);
  gluCylinder(quadric, 0.1, 0.1, 0.8, 8, 1);
  //cauda
  glTranslatef(0, 0, -0.05);
  gluCylinder(quadric, 0.0, 0.1, 0.05, 8, 1);
  glPopMatrix();

  /*missil2*/
  glPushMatrix();
  //posiciona
  glTranslatef(2, -0.11, 1);
  quadric = gluNewQuadric();
  gluQuadricTexture(quadric, GL_TRUE);
  //bico
  gluCylinder(quadric, 0.1, 0.0, 0.4, 8, 1);
  //corpo
  glTranslatef(0, 0, -0.8);
  gluCylinder(quadric, 0.1, 0.1, 0.8, 8, 1);
  //cauda
  glTranslatef(0, 0, -0.05);
  gluCylinder(quadric, 0.0, 0.1, 0.05, 8, 1);
  glPopMatrix();

  /* corpo */
  quadric = gluNewQuadric();
  gluQuadricTexture(quadric, GL_TRUE);
  gluCylinder(quadric, 0.5, 0.5, 4, 12, 3);

  //guarda para turbina
  glPushMatrix();

  /* nariz */
  quadric = gluNewQuadric();
  gluQuadricTexture(quadric, GL_TRUE);
  glPushMatrix();
  glTranslatef(0,0,4);
  gluCylinder(quadric, 0.5, 0.0, 1.5, 12, 3);
  glPopMatrix();

  /* cauda */
  glBegin(GL_POLYGON);
  glTexCoord2fv(cta[0]); glVertex3fv(cauda[0]);
  glTexCoord2fv(cta[1]); glVertex3fv(cauda[1]);
  glTexCoord2fv(cta[2]); glVertex3fv(cauda[2]);
  glTexCoord2fv(cta[3]); glVertex3fv(cauda[3]);
  glEnd();

  /* turbina */
  //retorna mat para turbina
  glPopMatrix();
  glPushMatrix();
  glTranslatef(0,0,-1);

  quadric = gluNewQuadric();
  if (flame_is_on) {
    printf("%s\n", "isON");
    gluQuadricTexture(quadric, GL_TRUE);
    glBindTexture(GL_TEXTURE_2D,textura_chama);
    glColor4f(1.0,0.0,0.0,0.5);
    gluCylinder(quadric, 0.1, 0.497, 1, 12, 1);
  }

  glTranslatef(0,0,0.4);
  glDisable(GL_TEXTURE_2D);
  if (flame_is_on) {
    glColor4f(1.0,0.0,0.0,1.0);
  } else {
    glColor4f(0.34,0.34,0.34,1.0);
  }
  gluCylinder(quadric, 0, 0.495, 0.6, 12, 1);
  glTranslatef(0,0,0.35);

  glColor4f(COR_DA_TURBINA);
  gluCylinder(quadric, 0.4, 0.5, 0.25, 12, 1);
  glPopMatrix();
  /* end - turbina*/

  if(texturas){
    glEnable(GL_TEXTURE_2D);
  }

  /* logo na cauda*/
  glBindTexture(GL_TEXTURE_2D,logo_aviao);
  glColor4f(COR_DA_LOGO);

  glPushMatrix();
  glTranslatef(0.01,0,0);
  glBegin(GL_QUADS);
  glTexCoord2fv(ctl[0]); glVertex3fv(logo[3]);
  glTexCoord2fv(ctl[1]); glVertex3fv(logo[0]);
  glTexCoord2fv(ctl[2]); glVertex3fv(logo[1]);
  glTexCoord2fv(ctl[3]); glVertex3fv(logo[2]);
  glEnd();
  glPopMatrix();

  glPushMatrix();
  glTranslatef(-0.01,0,0);
  glBegin(GL_QUADS);
  glTexCoord2fv(ctl[0]); glVertex3fv(logo[3]);
  glTexCoord2fv(ctl[1]); glVertex3fv(logo[0]);
  glTexCoord2fv(ctl[2]); glVertex3fv(logo[1]);
  glTexCoord2fv(ctl[3]); glVertex3fv(logo[2]);
  glEnd();
  glPopMatrix();
  /*end - logo na cauda*/


  /* cabine do piloto */
  glDisable(GL_TEXTURE_2D);
  glTranslatef(0,0.3,3.5);
  glPushMatrix();
  glScalef(0.7,0.7,2.0);
  quadric=gluNewQuadric();
  glColor4f(0.3,0.5,1,0.5);
  gluSphere(quadric,0.5,12,12);
  glPopMatrix();


  /* termina a composicao do jato*/
  glEndList();
}

void display(void){
  glEnable(GL_DEPTH_TEST);

  //glDepthMask(GL_TRUE);
  glClearColor(1.0,1.0,1.0,1.0);
  glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);

  glPushMatrix();

  /* calcula a posicao do observador */
  obs[0]=raioxz*cos(2*PI*tetaxz/360);
  obs[2]=raioxz*sin(2*PI*tetaxz/360);
  gluLookAt(obs[0],obs[1],obs[2],look[0],look[1],look[2],0.0,1.0,0.0);

  /* habilita/desabilita uso de texturas*/
  if(texturas){
    glEnable(GL_TEXTURE_2D);
  }
  else{
    glDisable(GL_TEXTURE_2D);
  }
  glTexEnvf(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_DECAL);

  // grava a transformacao atual
  glPushMatrix();
  //plano texturizado
  glColor4f(COR_DO_PLANO);
  glPolygonMode( GL_FRONT_AND_BACK, GL_FILL );
  glBindTexture(GL_TEXTURE_2D,textura_plano);
  glBegin(GL_QUADS);
  glTexCoord2fv(ctp[0]);  glVertex3f(-10,0,10);
  glTexCoord2fv(ctp[1]);  glVertex3f(10,0,10);
  glTexCoord2fv(ctp[2]);  glVertex3f(10,0,-10);
  glTexCoord2fv(ctp[3]);  glVertex3f(-10,0,-10);
  glEnd();

  //aviao texturizado
  glTranslatef(0.0,2.0,-3.0);
  glColor4f(COR_DO_AVIAO);
  glBindTexture(GL_TEXTURE_2D,textura_aviao);
  glCallList(jato);
  glPopMatrix();
  // volta para a ultima transformacao

  // grava a transformacao atual
  glPushMatrix();
  glPolygonMode( GL_FRONT_AND_BACK, GL_LINE );
  glColor4f(COR_DO_PLANO);
  glBindTexture(GL_TEXTURE_2D,textura_plano);

  glBegin(GL_QUADS);
  glTexCoord2fv(ctp[0]);  glVertex3f(-10,0,10);
  glTexCoord2fv(ctp[1]);  glVertex3f(10,0,10);
  glTexCoord2fv(ctp[2]);  glVertex3f(10,0,-10);
  glTexCoord2fv(ctp[3]);  glVertex3f(-10,0,-10);
  glEnd();
  glTranslatef(0.0,2.0,-3.0);
  glColor4f(COR_DO_AVIAO);
  glBindTexture(GL_TEXTURE_2D,textura_aviao);
  glCallList(jato);
  glPopMatrix();
  // volta para a ultima transformacao

  glPopMatrix();
  glutSwapBuffers();
}


void special(int key, int x, int y){
  switch (key) {
  case GLUT_KEY_UP:
    obs[1]=obs[1]+1;
    glutPostRedisplay();
    break;
  case GLUT_KEY_DOWN:
    obs[1] =obs[1]-1;
    glutPostRedisplay();
    break;
  case GLUT_KEY_LEFT:
    tetaxz=tetaxz+2;
    glutPostRedisplay();
    break;
  case GLUT_KEY_RIGHT:
    tetaxz=tetaxz-2;
    glutPostRedisplay();
    break;
  }
}

void keyboard(unsigned char key, int x, int y){
  switch (key) {
  case 27:
    exit(0);
    break;
  case 't':
    texturas = !texturas;
    glutPostRedisplay();
    break;
  case 'r':
    raioxz=raioxz+1;
    glutPostRedisplay();
    break;
  case 'R':
    raioxz=raioxz-1;
    if(raioxz==0){
      raioxz=1;
    }
    glutPostRedisplay();
    break;
  case 'o':
    flame_is_on = !flame_is_on;
    compoe_jato();
    //printf("%i\n", flame_is_on);
    glutPostRedisplay();
    break;
  }
}

void carregar_texturas(void){
  textura_plano = png_texture_load(TEXTURA_DO_PLANO, NULL, NULL);
  textura_aviao = png_texture_load(TEXTURA_DO_AVIAO, NULL, NULL);
  logo_aviao = png_texture_load(LOGO_DO_AVIAO, NULL, NULL);
  textura_chama = png_texture_load(TEXTURA_DA_CHAMA, NULL, NULL);
}

void init(){
  glEnable(GL_DEPTH_TEST);

  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
  carregar_texturas();
  compoe_jato();
  //  glShadeModel(GL_FLAT);
  glEnable(GL_TEXTURE_2D);
}

int main(int argc,char **argv){
  glutInitWindowPosition(0,0);
  glutInitWindowSize(WIDTH,HEIGHT);
  glutInit(&amp;argc,argv);
  glutInitDisplayMode(GLUT_RGBA|GLUT_DEPTH|GLUT_DOUBLE|GLUT_ALPHA);

  if(!glutCreateWindow("Avião a jato")) {
    fprintf(stderr,"Error opening a window.\n");
    exit(-1);
  }

  init();

  glutKeyboardFunc(keyboard);
  glutSpecialFunc(special);
  glutDisplayFunc(display);
  glutReshapeFunc(reshape);
  glutMainLoop();

  return(0);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_imagem_18">8.2.3. Imagem</h4>
<div class="imageblock">
<div class="content">
<img src="ex/8/superjatologo1.png" alt="superjatologo1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="ex/8/superjatologo2.png" alt="superjatologo2">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_comentário_6">8.2.4. Comentário</h4>
<div class="paragraph">
<p>Para ligar e desligar a turbina precione a tecla 'o'.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2015-11-06 20:39:25 BRT
</div>
</div>
</body>
</html>