<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.2">
<meta name="author" content="Discente">
<title>COMPUTAÇÃO GRÁFICA 2015.2</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove the comments around the @import statement below when using this as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
body{margin:0}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
#map_canvas img,#map_canvas embed,#map_canvas object,.map_canvas img,.map_canvas embed,.map_canvas object{max-width:none!important}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
.antialiased,body{-webkit-font-smoothing:antialiased}
img{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol,ul.no-bullet,ol.no-bullet{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.no-bullet{list-style:none}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
.keyseq{color:rgba(51,51,51,.8)}
kbd{display:inline-block;color:rgba(0,0,0,.8);font-size:.75em;line-height:1.4;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:-.15em .15em 0 .15em;padding:.2em .6em .2em .5em;vertical-align:middle;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menu{color:rgba(0,0,0,.8)}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.05em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.spread{width:100%}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all th.tableblock,table.grid-all td.tableblock{border-width:0 1px 1px 0}
table.grid-all tfoot>tr>th.tableblock,table.grid-all tfoot>tr>td.tableblock{border-width:1px 1px 0 0}
table.grid-cols th.tableblock,table.grid-cols td.tableblock{border-width:0 1px 0 0}
table.grid-all *>tr>.tableblock:last-child,table.grid-cols *>tr>.tableblock:last-child{border-right-width:0}
table.grid-rows th.tableblock,table.grid-rows td.tableblock{border-width:0 0 1px 0}
table.grid-all tbody>tr:last-child>th.tableblock,table.grid-all tbody>tr:last-child>td.tableblock,table.grid-all thead:last-child>tr>th.tableblock,table.grid-rows tbody>tr:last-child>th.tableblock,table.grid-rows tbody>tr:last-child>td.tableblock,table.grid-rows thead:last-child>tr>th.tableblock{border-bottom-width:0}
table.grid-rows tfoot>tr>th.tableblock,table.grid-rows tfoot>tr>td.tableblock{border-width:1px 0 0 0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.unstyled,ol.unnumbered,ul.checklist,ul.none{list-style-type:none}
ul.unstyled,ol.unnumbered,ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1em;font-size:.85em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{width:1em;position:relative;top:1px}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1{padding-right:.75em;font-weight:bold}
td.hdlist1,td.hdlist2{vertical-align:top}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:0 .75em;line-height:1}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none}
span.footnote,span.footnoteref{vertical-align:super;font-size:.875em}
span.footnote a,span.footnoteref a{text-decoration:none}
span.footnote a:active,span.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em;line-height:1.3;font-size:.875em;margin-left:1.2em;text-indent:-1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
h1,h2{letter-spacing:-.01em}
dt,th.tableblock,td.content{text-rendering:optimizeLegibility}
p,td.content{letter-spacing:-.01em}
p strong,td.content strong{letter-spacing:-.005em}
p,blockquote,dt,td.content{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img{page-break-inside:avoid}
thead{display:table-header-group}
img{max-width:100%!important}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>document.addEventListener('DOMContentLoaded', prettyPrint)</script>
</head>
<body class="article toc2 toc-right">
<div id="header">
<h1>COMPUTAÇÃO GRÁFICA 2015.2</h1>
<div class="details">
<span id="author" class="author">Discente</span><br>
<span id="revdate">Hanoch Griner &lt;eugriner@gmail.com&gt;</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_conceitos_iniciais">1. Conceitos iniciais</a>
<ul class="sectlevel2">
<li><a href="#_quadrados_4">1.1. Quadrados 4</a></li>
<li><a href="#_quadrados_color">1.2. Quadrados Color</a></li>
</ul>
</li>
<li><a href="#_desenhando_linhas_e_pontos">2. Desenhando linhas e pontos</a>
<ul class="sectlevel2">
<li><a href="#_quadrado">2.1. Quadrado</a></li>
<li><a href="#_bresenham_linha">2.2. Bresenham Linha</a></li>
<li><a href="#_bresenham_círculo">2.3. Bresenham Círculo</a></li>
</ul>
</li>
<li><a href="#_preenchimento_de_regiões">3. Preenchimento de regiões</a>
<ul class="sectlevel2">
<li><a href="#_seleção">3.1. Seleção</a></li>
<li><a href="#_seleção_buffer_simples">3.2. Seleção Buffer Simples</a></li>
<li><a href="#_padrão_hg">3.3. Padrão HG</a></li>
</ul>
</li>
<li><a href="#_transformações_geométricas">4. Transformações Geométricas</a>
<ul class="sectlevel2">
<li><a href="#_braço_garra">4.1. Braço Garra</a></li>
<li><a href="#_braço_garra_3d">4.2. Braço Garra 3D</a></li>
</ul>
</li>
<li><a href="#_projeções_geométricas">5. Projeções geométricas</a>
<ul class="sectlevel2">
<li><a href="#_tipos_de_projeções">5.1. Tipos de Projeções</a></li>
<li><a href="#_projeções_animadas">5.2. Projeções Animadas</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Esse relatório contém a resolução dos exercícios referentes ao tutorial de OpenGL do docente Agostinho Brito.
<a href="http://agostinhobritojr.github.io/tutoriais/opengl/" class="bare">http://agostinhobritojr.github.io/tutoriais/opengl/</a></p>
</div>
<div class="paragraph">
<p>O relatório esta dividido em tópicos seguindo a estrutura do tutorial. Cada tópico contém: questão, seguida do código fonte desenvolvido/adaptado para resolver a questão e por último a imagem ou imagens geradas na execução do código.</p>
</div>
<div class="paragraph">
<p>Para compilar e executar qualquer arquivo desse relatório deve-se colocar o arquivo Makefile na mesma pasta do arquivo .c desejado e executar o seguinte comando:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ make arquivodesejado &amp;&amp; ./arquivodesejado</pre>
</div>
</div>
<div class="paragraph">
<p>Exemplo</p>
</div>
<div class="ulist">
<div class="title">Arquivos:</div>
<ul>
<li>
<p><a href="ex/Makefile" target="_blank">Makefile</a></p>
</li>
<li>
<p><a href="ex/teste.c" target="_blank">teste.c</a></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Comando:</div>
<div class="content">
<pre>$ make teste &amp;&amp; ./teste</pre>
</div>
</div>
<div class="paragraph">
<p>Lembre-se que você precisa ter o GLUT e um compilador C/C++ no seu computador, caso não de certo, siga as instruções do <a href="http://agostinhobritojr.github.io/tutoriais/opengl/conceitos-iniciais.html#compilando-programas" target="_blank">tutorial do professor</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conceitos_iniciais">1. Conceitos iniciais</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_quadrados_4">1.1. Quadrados 4</h3>
<div class="sect3">
<h4 id="_questão">1.1.1. Questão</h4>
<div class="paragraph">
<p>Utilizando o programa teste-make.c como referência, implemente um programa quadrados4.c. Este programa deverá desenhar numa janela com fundo branco, de dimensões 256x256 pixels, e quatro quadrados de cores diferentes arranjados na janela.</p>
</div>
<div class="ulist">
<div class="title">Arquivos:</div>
<ul>
<li>
<p><a href="ex/1/teste-make.c" target="_blank">teste-make.c</a></p>
</li>
<li>
<p><a href="ex/1/quadrados4.c" target="_blank">quadrados4.c</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_código">1.1.2. Código</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

void display(void);
void timer(int);
void keyboard(unsigned char key, int x, int y);

/* cores do quadrado */
GLfloat r=1.0, g=0.5, b=0.0;

int main(int argc, char** argv){
  glutInit(&amp;argc, argv);
  glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB);
  glutInitWindowSize (256, 256);
  glutInitWindowPosition (100, 100);
  glutCreateWindow (argv[0]);
  // inicia um temporizador. após 33ms ativa a funcao timer
  glutTimerFunc(33, timer, 1);
  glClearColor(1.0, 1.0, 1.0, 0.0);
  //glShadeModel (GL_FLAT);
  glOrtho (0, 1, 0, 1, -1 ,1);
  glutDisplayFunc(display);
  glutMainLoop();
  return 0;
}

void timer(int value){
  r=r+0.01;
  g=g+0.01;
  b=b+0.01;
  if(r&gt;1) r=0;
  if(g&gt;1) g=0;
  if(b&gt;1) b=0;
  glutPostRedisplay();
  glutTimerFunc(33, timer, 1);
}

void display(void){
  int i;
  glClear(GL_COLOR_BUFFER_BIT);

  // quadrado 1
  glBegin(GL_POLYGON);
  glColor3f (1.0, 0.0, 0.0);
  glVertex2f(0.25,0.25);
  glVertex2f(0.45,0.25);
  glVertex2f(0.45,0.45);
  glVertex2f(0.25,0.45);
  glEnd();
  // quadrado 2
  glBegin(GL_POLYGON);
  glColor3f (1.0, 1.0, 0.0);
  glVertex2f(0.25,0.55);
  glVertex2f(0.25,0.75);
  glVertex2f(0.45,0.75);
  glVertex2f(0.45,0.55);
  glEnd();
  //quadrado 3
  glBegin(GL_POLYGON);
  glColor3f (0.0, 1.0, 0.0);
  glVertex2f(0.55,0.55);
  glVertex2f(0.75,0.55);
  glVertex2f(0.75,0.75);
  glVertex2f(0.55,0.75);
  glEnd();
  //quadrado 4
  glBegin(GL_POLYGON);
  glColor3f (0.0, 1.0, 1.0);
  glVertex2f(0.55,0.25);
  glVertex2f(0.75,0.25);
  glVertex2f(0.75,0.45);
  glVertex2f(0.55,0.45);
  glEnd();
  glFlush();
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_imagem">1.1.3. Imagem</h4>
<div class="imageblock">
<div class="content">
<img src="ex/1/quadrados4.png" alt="quadrados4">
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_quadrados_color">1.2. Quadrados Color</h3>
<div class="sect3">
<h4 id="_questão_2">1.2.1. Questão</h4>
<div class="paragraph">
<p>Utilizando o programa teste-make.c como referência, implemente um programa quadradoscolor.c. Este programa deverá desenhar numa janela com fundo branco, de dimensões 256x256 pixels, um quadrado com as mesmas dimensões do quadrado original. Entretanto, cada uma das cores determinadas para os quatro vértices do quadrado deverão ser determinadas a partir de valores calculados via modelo HSI. Implemente um temporizador para os valores de H mudarem com o tempo para os vértices, produzindo uma pequena animação. Comente a linha glShadeModel(GL_FLAT) para que o feito de degradê possa ser visualizado.</p>
</div>
<div class="ulist">
<div class="title">Arquivos:</div>
<ul>
<li>
<p><a href="ex/1/teste-make.c" target="_blank">teste-make.c</a></p>
</li>
<li>
<p><a href="ex/1/quadradosColor.c" target="_blank">quadradosColor.c</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_código_2">1.2.2. Código</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;cmath&gt;

void display(void);
void timer(int);
void keyboard(unsigned char key, int x, int y);
void HSItoRGB(int h, float s, float i);
float rad(float a);

/* cores do quadrado */
GLfloat r=0.0, g=0.0, b=0.0;
float s, i;
int h;

int main(int argc, char** argv){
  h = 0;
  s = 1.0;
  i = 0.5;

  glutInit(&amp;argc, argv);
  glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB);
  glutInitWindowSize (256, 256);
  glutInitWindowPosition (100, 100);
  glutCreateWindow (argv[0]);
  // inicia um temporizador. após 33ms ativa a funcao timer
  glutTimerFunc(33, timer, 1);
  glClearColor(1.0, 1.0, 1.0, 0.0);
  //glShadeModel (GL_FLAT);
  glOrtho (0, 1, 0, 1, -1 ,1);
  glutDisplayFunc(display);
  glutMainLoop();
  return 0;
}

void timer(int value){
  h = h + 1;
  printf("h=%d\n", h);
  if(h&gt;90) h=0;
  glutPostRedisplay();
  glutTimerFunc(100, timer, 1);
}

void display(void){
  glClear(GL_COLOR_BUFFER_BIT);
  glBegin(GL_POLYGON);

  //v1
  //
  //.
  HSItoRGB(h, s, i);
  glColor3f (r, g, b);
  printf("(%f,%f,%f)\n",r,g,b );
  glVertex2f(0.25,0.25);

  //v2
  //
  //.  .
  HSItoRGB(h+180, s, i);
  glColor3f (r, g, b);
  printf("(%f,%f,%f)\n",r,g,b );
  glVertex2f(0.75,0.25);

  //v3
  //   .
  //.  .
  HSItoRGB(h+90, s, i);
  glColor3f (r, g, b);
  printf("(%f,%f,%f)\n",r,g,b );
  glVertex2f(0.75,0.75);

  //v4
  //.  .
  //.  .
  HSItoRGB(h+270, s, i);
  glColor3f (r, g, b);
  printf("(%f,%f,%f)\n",r,g,b );
  glVertex2f(0.25,0.75);
  glEnd();
  glFlush();
}

void HSItoRGB(int h, float s, float i) {
  if (h&gt;= 0 &amp;&amp; h &lt; 120)
  {
    b = i*(1-s)/3;
    r = i*(1+(s*cos(rad(h))/cos(rad(60-h))))/3;
    g = i*(1-(r+b));
  } else if (h &lt; 240)
  {
    h = h-120;
    r = i*(1-s)/3;
    g = i*(1+(s*cos(rad(h))/cos(rad(60-h))))/3;
    b = i*(1-(r+g));
  } else if (h &lt;= 360)
  {
    h = h-240;
    g = i*(1-s)/3;
    b = i*(1+(s*cos(rad(h))/cos(rad(60-h))))/3;
    r = i*(1-(g+b));
  } else {
    printf("\nERROR - Invalid Color!!\n");
  }
}
float rad(float a) {
  return a*M_PI/180.0;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_imagem_2">1.2.3. Imagem</h4>
<div class="imageblock">
<div class="content">
<img src="ex/1/quadradosColor1.png" alt="quadradosColor1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="ex/1/quadradosColor2.png" alt="quadradosColor2">
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_desenhando_linhas_e_pontos">2. Desenhando linhas e pontos</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_quadrado">2.1. Quadrado</h3>
<div class="sect3">
<h4 id="_questão_3">2.1.1. Questão</h4>
<div class="paragraph">
<p>Utilizando o programa linha.c como referência, implemente um programa quadrado.c. Este programa deverá desenhar numa janela com fundo branco, de dimensões 256x256 pixels, um quadrado vermelho, com vértice superior esquerdo de coordenadas (x, y)= (30, 226) e vértice inferior direito de coordenadas (x, y) = (226, 30). Quando a tecla a (keycode=97) for pressionada, o quadrado deverá ficar com a cor azul. Quando a tecla v (keycode=118) for pressionada, o quadrado deverá voltar à cor vermelha.</p>
</div>
<div class="ulist">
<div class="title">Arquivos:</div>
<ul>
<li>
<p><a href="ex/2/linha.c" target="_blank">linha.c</a></p>
</li>
<li>
<p><a href="ex/2/quadrado.c" target="_blank">quadrado.c</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_código_3">2.1.2. Código</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;

void init(void);
void display(void);
void keyboard(unsigned char key, int x, int y);

int main(int argc, char** argv){
  glutInit(&amp;argc, argv);
  glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB);
  glutInitWindowSize (256, 256);
  glutInitWindowPosition (100, 100);
  glutCreateWindow ("Desenhando um quadrado");
  init();
  glutDisplayFunc(display);
  glutKeyboardFunc(keyboard);
  glutMainLoop();
  return 0;
}

void init(void){
  glClearColor(1.0, 1.0, 1.0, 1.0);
  glOrtho (0, 256, 0, 256, -1 ,1);
  //pinta inicialmente de vermelho
  glColor3f (1.0, 0.0, 0.0);
}

void display(void){
  int i;
  glClear(GL_COLOR_BUFFER_BIT);
  glBegin(GL_LINES);
  glVertex2i(30,226); glVertex2i(226,226);
  glVertex2i(226,226); glVertex2i(226,30);
  glVertex2i(226,30); glVertex2i(30,30);
  glVertex2i(30,30); glVertex2i(30, 226);
  glEnd();
  glFlush();
}

void keyboard(unsigned char key, int x, int y){
  //switch entre Azul e Vermelho
  switch (key) {
    case 'a':
      //escolhe a cor azul
      glColor3f (0.0, 0.0, 1.0);
      //redesenha "display(void)"
      glutPostRedisplay();
      break;
    case 'v':
      glColor3f (1.0, 0.0, 0.0);
      glutPostRedisplay();
      break;
    case 27:
  	exit(0);
  	break;
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_imagem_3">2.1.3. Imagem</h4>
<div class="imageblock">
<div class="content">
<img src="ex/2/quadrado1.png" alt="quadrado1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="ex/2/quadrado2.png" alt="quadrado2">
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_bresenham_linha">2.2. Bresenham Linha</h3>
<div class="sect3">
<h4 id="_questão_4">2.2.1. Questão</h4>
<div class="paragraph">
<p>Implemente o algoritmo de Bresenham para traçado de linhas, utilizando GL_POINTS como parâmetro da função glBegin(). Este parâmetro indica que cada vértice deve ser tratado como um ponto simples. Utilizando o algoritmo implementado, desenhe uma reta verde do ponto (x, y)=(40, 200) ao ponto (x, y)=(200, 10).</p>
</div>
<div class="ulist">
<div class="title">Arquivos:</div>
<ul>
<li>
<p><a href="ex/2/bresenhamLinha.c" target="_blank">bresenhamLinha.c</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_código_4">2.2.2. Código</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;cmath&gt;
#include &lt;stdio.h&gt;

void init(void);
void display(void);
void keyboard(unsigned char key, int x, int y);
void bresenDraw(int x1, int y1, int x2, int y2);
void trash(void);

int main(int argc, char** argv) {
  glutInit(&amp;argc, argv);
  glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB);
  glutInitWindowSize (256, 256);
  glutInitWindowPosition (100, 100);
  glutCreateWindow ("Desenhando uma linha");
  init();
  glutDisplayFunc(display);
  glutKeyboardFunc(keyboard);
  glutMainLoop();
  return 0;
}

void init(void) {
  glClearColor(1.0, 1.0, 1.0, 1.0);
  glOrtho (0, 256, 0, 256, -1 , 1);
}

void display(void) {
  int i;
  glClear(GL_COLOR_BUFFER_BIT);
  glColor3f (0.0, 0.0, 0.0);
  glBegin(GL_POINTS);
  int x0 = 40;
  int x1 = 200;
  int y0 = 200;
  int y1 = 10;

  bresenDraw(40, 200, 200, 10);

  glEnd();
  glFlush();
}

void keyboard(unsigned char key, int x, int y) {
  switch (key) {
  case 27:
    exit(0);
    break;
  }
}

void bresenDraw(int x1, int y1, int x2, int y2) {
  int x = x1;
  int y = y1;
  int Delta_x = abs(x2 - x1);
  int Delta_y = abs(y2 - y1);
  int s1 = (x2 &gt; x1) ? 1 : -1;
  int s2 = (y2 &gt; y1) ? 1 : -1;
  int Troca, i;
  if (Delta_y &gt; Delta_x) {
    int Temp = Delta_x;
    Delta_x = Delta_y;
    Delta_y = Temp;
    Troca = 1;
  }
  else {
    Troca = 0;
  }
  int new_e = 2 * Delta_y - Delta_x;
  for (i = 1; i &lt;= Delta_x; i++) {
    glVertex2i(x, y);
    while (new_e &gt;= 0) {
      if (Troca == 1) {
        //Muda para a proxima linha de rasterização
        x = x + s1;
      }
      else {
        y = y + s2;
      }
      new_e = new_e - 2 * Delta_x;
    }

    //Permanece nesta linha de rasterização
    if (Troca == 1) {
      y = y + s2;
    }
    else {
      x = x + s1;
    }
    new_e = new_e + 2 * Delta_y;
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_imagem_4">2.2.3. Imagem</h4>
<div class="imageblock">
<div class="content">
<img src="ex/2/bresenhamLinha.png" alt="bresenhamLinha">
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_bresenham_círculo">2.3. Bresenham Círculo</h3>
<div class="sect3">
<h4 id="_questão_5">2.3.1. Questão</h4>
<div class="paragraph">
<p>Implemente o algoritmo de Bresenham para traçado de circunferências, utilizando GL_POINTS como parâmetro da função glBegin(). Utilizando o algoritmo implementado, desenhe uma circunferência azul de raio r=50, centrada no ponto (x, y) = (128, 128).</p>
</div>
<div class="ulist">
<div class="title">Arquivos:</div>
<ul>
<li>
<p><a href="ex/2/bresenhamCircle.c" target="_blank">bresenhamCircle.c</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_código_5">2.3.2. Código</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;cmath&gt;
#include &lt;stdio.h&gt;

void init(void);
void display(void);
void keyboard(unsigned char key, int x, int y);
void bresenDraw(int x, int y, int raio);
void pontosDaCircunferencia(int x, int y, int xc, int yc);

int main(int argc, char** argv) {
  glutInit(&amp;argc, argv);
  glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB);
  glutInitWindowSize (256, 256);
  glutInitWindowPosition (100, 100);
  glutCreateWindow ("Desenhando uma linha");
  init();
  glutDisplayFunc(display);
  glutKeyboardFunc(keyboard);
  glutMainLoop();
  return 0;
}

void init(void) {
  glClearColor(1.0, 1.0, 1.0, 1.0);
  glOrtho (0, 256, 0, 256, -1 , 1);
}

void display(void) {
  int i;
  glClear(GL_COLOR_BUFFER_BIT);
  glColor3f (0.0, 0.0, 0.0);
  glBegin(GL_POINTS);

  bresenDraw(128, 128, 50);

  glEnd();
  glFlush();
}

void keyboard(unsigned char key, int x, int y) {
  switch (key) {
  case 27:
    exit(0);
    break;
  }
}

void bresenDraw(int xc, int yc, int raio) {
  int x = 0;
  int y = raio;
  int d = 1 - raio;
  pontosDaCircunferencia(x, y, xc, yc);
  while (y &gt; x) {
    if (d &lt; 0) {
      d = d + 2 * x + 3;
      x = x + 1;
    }
    else {
      d = d + 2 * (x - y) + 5;
      x = x + 1;
      y = y - 1;
    }
    pontosDaCircunferencia(x, y, xc, yc);
  }
}

void pontosDaCircunferencia(int x, int y, int xc, int yc) {
                    //Octantes
  glVertex2i(x+xc,y+yc);  //1
  glVertex2i(y+xc,x+yc);  //2
  glVertex2i(y+xc,-x+yc); //3
  glVertex2i(x+xc,-y+yc); //4
  glVertex2i(-x+xc,-y+yc);//5
  glVertex2i(-y+xc,-x+yc);//6
  glVertex2i(-y+xc,x+yc); //7
  glVertex2i(-x+xc,y+yc); //8
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_imagem_5">2.3.3. Imagem</h4>
<div class="imageblock">
<div class="content">
<img src="ex/2/bresenhamCircle.png" alt="bresenhamCircle">
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_preenchimento_de_regiões">3. Preenchimento de regiões</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_seleção">3.1. Seleção</h3>
<div class="sect3">
<h4 id="_questão_6">3.1.1. Questão</h4>
<div class="paragraph">
<p>Utilizando o programa preenchimento.c como referência, implemente um programa selecao.c. Este programa deverá desenhar numa janela com fundo branco, de dimensões 256x256 pixels, quatro polígonos com as mesmas coordenadas dos polígonos do programa de referência. Todos os polígonos devem estar inicialmente preenchidos de amarelo e com bordas pretas. Quando o usuário clicar com o botão esquerdo do mouse dentro de um dos polígonos, a cor de preechimento deste polígono deverá mudar para uma cor aleatória. Quando a tecla b (keycode=98) for pressionada, o programa passará a mudar as cores das bordas e não mais dos fundos dos polígonos. Quando a tecla f (keycode=102) for pressionada, o programa passará a mudar as cores dos fundos dos polígonos e não mais das bordas.</p>
</div>
<div class="ulist">
<div class="title">Arquivos:</div>
<ul>
<li>
<p><a href="ex/3/preenchimento.c" target="_blank">preenchimento.c</a></p>
</li>
<li>
<p><a href="ex/3/selecao.c" target="_blank">selecao.c</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_código_6">3.1.2. Código</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

GLfloat rb[4], gb[4], bb[4], rf[4], gf[4], bf[4];
int qx[4], qy[4];
int posX, posY;
bool flagKey;
void init(void);
void display(void);
void keyboard(unsigned char key, int x, int y);
void mouse(int button, int state, int x, int y);
void square(int qn);

int main(int argc, char** argv) {
  glutInit(&amp;argc, argv);
  glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB);
  glutInitWindowSize (256, 256);
  glutInitWindowPosition (100, 100);
  glutCreateWindow ("Preenchendo regioes");
  init();
  glutDisplayFunc(display);
  glutKeyboardFunc(keyboard);
  glutMouseFunc(mouse);
  glutMainLoop();
  return 0;
}

void init(void) {
  glClearColor(1.0, 1.0, 1.0, 1.0);
  glOrtho (0, 256, 0, 256, -1 , 1);
  for (int i = 0; i &lt; 4; ++i)
  {
    rb[i] = 0; gb[i] = 0; bb[i] = 0;
    rf[i] = 1; gf[i] = 1; bf[i] = 0;
  }

  flagKey = 1;
  qx[0] = 30;
  qy[0] = 226;
  qx[1] = 143;
  qy[1] = 226;
  qx[2] = 30;
  qy[2] = 113;
  qx[3] = 143;
  qy[3] = 113;
  posX = 0; posY = 0;
}

void display(void) {
  int i;
  glClear(GL_COLOR_BUFFER_BIT);
  glDisable(GL_POLYGON_STIPPLE);

  square(0);
  square(1);
  square(2);
  square(3);

  glFlush();
  glutSwapBuffers();
}

void keyboard(unsigned char key, int x, int y) {
  switch (key) {
  case 'b':
    flagKey = 0;
    break;
  case 'f':
    flagKey = 1;
    break;
  case 27:
    exit(0);
    break;
  }
}

void mouse(int button, int state, int x, int y) {
  posX = x;
  //O eixo y do rastreamento do mouse é o inverso do de desenho do openGL, why!!!???
  posY = (y-256)*-1;
  //posY = y;
  switch (button) {
  case GLUT_LEFT_BUTTON:
    if (state == GLUT_DOWN) {
      //printf("(%d,%d)\n", posX, posY);
      glutPostRedisplay();
    }
    break;
  }
}

void square(int qn) {
  int x = qx[qn];
  int y = qy[qn];
  //printf("Qn=%d, X=%d, Y=%d\n",qn, x, y);
  //printf("(X=%d)\n", (x &lt;= posX &amp;&amp; (x+83) &gt;= posX));
  //printf("(Y=%d)\n", (y &lt;= posY &amp;&amp; (y-83) &gt;= posY));
  if ((x &lt;= posX &amp;&amp; (x+83) &gt;= posX) &amp;&amp; (y &gt;= posY &amp;&amp; (y-83) &lt;= posY))
  {
    if (flagKey)
    {
      rf[qn] = (GLfloat)rand() / (RAND_MAX + 1.0);
      gf[qn] = (GLfloat)rand() / (RAND_MAX + 1.0);
      bf[qn] = (GLfloat)rand() / (RAND_MAX + 1.0);
    } else {
      rb[qn] = (GLfloat)rand() / (RAND_MAX + 1.0);
      gb[qn] = (GLfloat)rand() / (RAND_MAX + 1.0);
      bb[qn] = (GLfloat)rand() / (RAND_MAX + 1.0);
    }
  }
  glPolygonMode(GL_BACK, GL_FILL);
  glColor3f(rf[qn], gf[qn], bf[qn]);
  glBegin(GL_POLYGON);
  glVertex2i(x, y); glVertex2i(x + 83, y);
  glVertex2i(x + 83, y - 83); glVertex2i(x, y - 83);
  glEnd();

  glPolygonMode(GL_BACK, GL_LINE);
  glColor3f(rb[qn], gb[qn], bb[qn]);
  glBegin(GL_POLYGON);
  glVertex2i(x, y); glVertex2i(x + 83, y);
  glVertex2i(x + 83, y - 83); glVertex2i(x, y - 83);
  glEnd();
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_imagem_6">3.1.3. Imagem</h4>
<div class="imageblock">
<div class="content">
<img src="ex/3/selecao1.png" alt="selecao1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="ex/3/selecao2.png" alt="selecao2">
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_seleção_buffer_simples">3.2. Seleção Buffer Simples</h3>
<div class="sect3">
<h4 id="_questão_7">3.2.1. Questão</h4>
<div class="paragraph">
<p>Repita o item anterior utilizando buffer simples e comente os resultados obtidos.</p>
</div>
<div class="ulist">
<div class="title">Arquivos:</div>
<ul>
<li>
<p><a href="ex/3/selecaoBS.c" target="_blank">selecaoBS.c</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_código_7">3.2.2. Código</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

GLfloat rb[4], gb[4], bb[4], rf[4], gf[4], bf[4];
int qx[4], qy[4];
int posX, posY;
bool flagKey;
void init(void);
void display(void);
void keyboard(unsigned char key, int x, int y);
void mouse(int button, int state, int x, int y);
void square(int qn);

int main(int argc, char** argv) {
  glutInit(&amp;argc, argv);
  glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB);
  glutInitWindowSize (256, 256);
  glutInitWindowPosition (100, 100);
  glutCreateWindow ("Preenchendo regioes");
  init();
  glutDisplayFunc(display);
  glutKeyboardFunc(keyboard);
  glutMouseFunc(mouse);
  glutMainLoop();
  return 0;
}

void init(void) {
  glClearColor(1.0, 1.0, 1.0, 1.0);
  glOrtho (0, 256, 0, 256, -1 , 1);
  for (int i = 0; i &lt; 4; ++i)
  {
    rb[i] = 0; gb[i] = 0; bb[i] = 0;
    rf[i] = 1; gf[i] = 1; bf[i] = 0;
  }

  flagKey = 1;
  qx[0] = 30;
  qy[0] = 226;
  qx[1] = 143;
  qy[1] = 226;
  qx[2] = 30;
  qy[2] = 113;
  qx[3] = 143;
  qy[3] = 113;
  posX = 0; posY = 0;
}

void display(void) {
  int i;
  glClear(GL_COLOR_BUFFER_BIT);
  glDisable(GL_POLYGON_STIPPLE);

  square(0);
  square(1);
  square(2);
  square(3);

  glFlush();
  //glutSwapBuffers();
}

void keyboard(unsigned char key, int x, int y) {
  switch (key) {
  case 'b':
    flagKey = 0;
    break;
  case 'f':
    flagKey = 1;
    break;
  case 27:
    exit(0);
    break;
  }
}

void mouse(int button, int state, int x, int y) {
  posX = x;
  //O eixo y do rastreamento do mouse é o inverso do de desenho do openGL, why!!!???
  posY = (y-256)*-1;
  //posY = y;
  switch (button) {
  case GLUT_LEFT_BUTTON:
    if (state == GLUT_DOWN) {
      //printf("(%d,%d)\n", posX, posY);
      glutPostRedisplay();
    }
    break;
  }
}

void square(int qn) {
  int x = qx[qn];
  int y = qy[qn];
  //printf("Qn=%d, X=%d, Y=%d\n",qn, x, y);
  //printf("(X=%d)\n", (x &lt;= posX &amp;&amp; (x+83) &gt;= posX));
  //printf("(Y=%d)\n", (y &lt;= posY &amp;&amp; (y-83) &gt;= posY));
  if ((x &lt;= posX &amp;&amp; (x+83) &gt;= posX) &amp;&amp; (y &gt;= posY &amp;&amp; (y-83) &lt;= posY))
  {
    if (flagKey)
    {
      rf[qn] = (GLfloat)rand() / (RAND_MAX + 1.0);
      gf[qn] = (GLfloat)rand() / (RAND_MAX + 1.0);
      bf[qn] = (GLfloat)rand() / (RAND_MAX + 1.0);
    } else {
      rb[qn] = (GLfloat)rand() / (RAND_MAX + 1.0);
      gb[qn] = (GLfloat)rand() / (RAND_MAX + 1.0);
      bb[qn] = (GLfloat)rand() / (RAND_MAX + 1.0);
    }
  }
  glPolygonMode(GL_BACK, GL_FILL);
  glColor3f(rf[qn], gf[qn], bf[qn]);
  glBegin(GL_POLYGON);
  glVertex2i(x, y); glVertex2i(x + 83, y);
  glVertex2i(x + 83, y - 83); glVertex2i(x, y - 83);
  glEnd();

  glPolygonMode(GL_BACK, GL_LINE);
  glColor3f(rb[qn], gb[qn], bb[qn]);
  glBegin(GL_POLYGON);
  glVertex2i(x, y); glVertex2i(x + 83, y);
  glVertex2i(x + 83, y - 83); glVertex2i(x, y - 83);
  glEnd();
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_imagem_7">3.2.3. Imagem</h4>
<div class="imageblock">
<div class="content">
<img src="ex/3/selecaoBS.png" alt="selecaoBS">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_comentário">3.2.4. Comentário</h4>
<div class="paragraph">
<p>Meus olhos destreinados não foram capazes de notar nenhuma alteração após alterar de DOUBLE para SINGLE e desabilitar o swap.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_padrão_hg">3.3. Padrão HG</h3>
<div class="sect3">
<h4 id="_questão_8">3.3.1. Questão</h4>
<div class="paragraph">
<p>Crie um padrão de preenchimento com as iniciais dos seu nome e sobre nome, por exemplo, AB, para Agostinho Brito. Implemente um programa que desenhe em uma janela de fundo branco de dimensões 300x300 pixels um hexágono com bounding box de dimensões 200x200 pixels. O hexágono deve estar centrado na tela e preenchido com cor azul, utilize este padrão de preenchimento criado.</p>
</div>
<div class="ulist">
<div class="title">Arquivos:</div>
<ul>
<li>
<p><a href="ex/3/padrao.c" target="_blank">padrao.c</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_código_8">3.3.2. Código</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;

GLubyte tux[] = {
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x08, 0x20, 0x03, 0xF8,
  0x08, 0x20, 0x02, 0x08,
  0x08, 0x20, 0x02, 0x08,
  0x08, 0x20, 0x02, 0x08,
  0x08, 0x20, 0x02, 0x08,
  0x08, 0x20, 0x02, 0x08,
  0x08, 0x20, 0x02, 0x08,
  0x08, 0x20, 0x02, 0x08,
  0x08, 0x20, 0x02, 0x08,
  0x08, 0x20, 0x02, 0x08,
  0x08, 0x20, 0x02, 0x08,
  0x08, 0x20, 0x02, 0x08,
  0x0F, 0xE0, 0x02, 0x38,
  0x08, 0x20, 0x02, 0x00,
  0x08, 0x20, 0x02, 0x00,
  0x08, 0x20, 0x02, 0x00,
  0x08, 0x20, 0x02, 0x00,
  0x08, 0x20, 0x02, 0x00,
  0x08, 0x20, 0x02, 0x00,
  0x08, 0x20, 0x02, 0x00,
  0x08, 0x20, 0x02, 0x00,
  0x08, 0x20, 0x02, 0x00,
  0x08, 0x20, 0x02, 0x00,
  0x08, 0x20, 0x03, 0xF8,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00
};

GLfloat r, g, b;

void init(void);
void display(void);
void keyboard(unsigned char key, int x, int y);
void mouse(int button, int state, int x, int y);

int main(int argc, char** argv) {
  glutInit(&amp;argc, argv);
  glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB);
  glutInitWindowSize (300, 300);
  glutInitWindowPosition (100, 100);
  glutCreateWindow ("Preenchendo regiões");
  init();
  glutDisplayFunc(display);
  glutKeyboardFunc(keyboard);
  glutMouseFunc(mouse);
  glutMainLoop();
  return 0;
}

void init(void) {
  glClearColor(1.0, 1.0, 1.0, 1.0);
  glOrtho (0, 300, 0, 300, -1 , 1);
  r = 0; g = 0; b = 1;
}

void display(void) {
  int i;
  glClear(GL_COLOR_BUFFER_BIT);
  glDisable(GL_POLYGON_STIPPLE);

  glEnable(GL_POLYGON_STIPPLE);
  glColor3f(r, g, 1.0);
  glPolygonStipple(tux);
  glBegin(GL_POLYGON);
  glVertex2i(100, 63); glVertex2i(50, 150); glVertex2i(100, 237);
  glVertex2i(200, 237); glVertex2i(250, 150); glVertex2i(200, 63);
  glEnd();
  glFlush();
  glutSwapBuffers();
}

void keyboard(unsigned char key, int x, int y) {
  switch (key) {
  case 27:
    exit(0);
    break;
  }
}

void mouse(int button, int state, int x, int y) {
  switch (button) {
  case GLUT_LEFT_BUTTON:
    if (state == GLUT_DOWN) {
      r = (GLfloat)rand() / (RAND_MAX + 1.0);
      g = (GLfloat)rand() / (RAND_MAX + 1.0);
      b = (GLfloat)rand() / (RAND_MAX + 1.0);
      glutPostRedisplay();
    }
    break;
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_imagem_8">3.3.3. Imagem</h4>
<div class="imageblock">
<div class="content">
<img src="ex/3/padrao.png" alt="padrao">
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_transformações_geométricas">4. Transformações Geométricas</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_braço_garra">4.1. Braço Garra</h3>
<div class="sect3">
<h4 id="_questão_9">4.1.1. Questão</h4>
<div class="paragraph">
<p>Utilizando o programa braco.c como referência, implemente um programa braco-garra.c. Este programa deverá acrescente ao braço robótico uma garra com três dedos, sendo um indicador, um médio e um polegar, como mostra a Figura 4.3. O usuário deverá poder rotacionar o dedo indicador com as teclas i e I, nos sentidos horário e anti-horário. Da mesma forma, as teclas p P deverão rotacionar o polegar, e teclas m M, o dedo médio do robô.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="ex/4/Figura4.3.png" alt="Figura4.3">
</div>
</div>
<div class="ulist">
<div class="title">Arquivos:</div>
<ul>
<li>
<p><a href="ex/4/braco.c" target="_blank">braco.c</a></p>
</li>
<li>
<p><a href="ex/4/braco-garra.c" target="_blank">braco-garra.c</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_código_9">4.1.2. Código</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;

static int shoulder = 0, elbow = 0, thumb = 0, index = 0, middle = 0;

void init(void){
  glClearColor (0.0, 0.0, 0.0, 0.0);
}

void display(void){
  glClear (GL_COLOR_BUFFER_BIT);
  glPushMatrix();

  /* origem posicionada no ombro */
  glTranslatef (-1.0, 0.0, 0.0);
  glRotatef ((GLfloat) shoulder, 0.0, 0.0, 1.0);

  /* origem posicionada no centro do braco */
  glTranslatef (1.0, 0.0, 0.0);
  glPushMatrix();
  glScalef (2.0, 0.4, 1.0);
  glutWireCube (1.0);
  glPopMatrix();

  /* origem posicionada no cotovelo */
  glTranslatef (1.0, 0.0, 0.0);
  glRotatef ((GLfloat) elbow, 0.0, 0.0, 1.0);
  glTranslatef (1.0, 0.0, 0.0);
  glPushMatrix();
  glScalef (2.0, 0.4, 1.0);
  glutWireCube (1.0);
  glPopMatrix();

  /* origem posicionada no dedao */
	glTranslatef (1.0, 0.0, 0.0);
	glPushMatrix();
  glTranslatef (0.0, -0.2, 0.0);
  glRotatef ((GLfloat) thumb, 0.0, 0.0, 1.0);
  glTranslatef (0.25, 0.0, 0.0);
	glScalef (0.5, 0.1, 0.33);
  glutWireCube (1.0);
  glPopMatrix();

  /* origem posicionada no indicador */
  glTranslatef (0.0, 0.2, 0.0);
	glPushMatrix();
	glTranslatef (0.0, 0.0, 0.25);
  glRotatef ((GLfloat) index, 0.0, 0.0, 1.0);
  glTranslatef (0.25, 0.0, 0.0);
	glScalef (0.5, 0.1, 0.33);
  glutWireCube (1.0);
  glPopMatrix();

  /* origem posicionada no middle */
	glTranslatef (0.0, 0.0, -0.25);
  glRotatef ((GLfloat) middle, 0.0, 0.0, 1.0);
  glTranslatef (0.25, 0.0, 0.0);
	glScalef (0.5, 0.1, 0.33);
  glutWireCube (1.0);
  glPopMatrix();

  /* origem volta para o sistema de coordenadas original */
  glPopMatrix();
  glutSwapBuffers();
}

void reshape (int w, int h){
  glViewport (0, 0, (GLsizei) w, (GLsizei) h);
  glMatrixMode (GL_PROJECTION);
  glLoadIdentity ();
  gluPerspective(65.0, (GLfloat) w/(GLfloat) h, 1.0, 20.0);
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  glTranslatef (0.0, 0.0, -10.0);
}

void keyboard (unsigned char key, int x, int y){
  switch (key) {
  case 's':
    shoulder = (shoulder + 5) % 360;
    glutPostRedisplay();
    break;
  case 'S':
    shoulder = (shoulder - 5) % 360;
    glutPostRedisplay();
    break;
  case 'e':
    elbow = (elbow + 5) % 360;
    glutPostRedisplay();
    break;
  case 'E':
    elbow = (elbow - 5) % 360;
    glutPostRedisplay();
    break;
  case 'p':
    thumb = (thumb + 5) % 360;
    glutPostRedisplay();
    break;
  case 'P':
    thumb = (thumb - 5) % 360;
    glutPostRedisplay();
    break;
  case 'i':
    index = (index + 5) % 360;
    glutPostRedisplay();
    break;
  case 'I':
    index = (index - 5) % 360;
    glutPostRedisplay();
    break;
  case 'm':
    middle = (middle + 5) % 360;
    glutPostRedisplay();
    break;
  case 'M':
    middle = (middle - 5) % 360;
    glutPostRedisplay();
    break;
  case 27:
    exit(0);
    break;
  default:
    break;
  }
}

int main(int argc, char** argv){
  glutInit(&amp;argc, argv);
  glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB);
  glutInitWindowSize (600, 600);
  glutInitWindowPosition (100, 100);
  glutCreateWindow (argv[0]);
  init ();
  glutDisplayFunc(display);
  glutReshapeFunc(reshape);
  glutKeyboardFunc(keyboard);
  glutMainLoop();
  return 0;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_imagem_9">4.1.3. Imagem</h4>
<div class="imageblock">
<div class="content">
<img src="ex/4/braco-garra1.png" alt="braco garra1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="ex/4/braco-garra2.png" alt="braco garra2">
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_braço_garra_3d">4.2. Braço Garra 3D</h3>
<div class="sect3">
<h4 id="_questão_10">4.2.1. Questão</h4>
<div class="paragraph">
<p>Copie o programa braco-garra.c que você criou com o nome braco-garra-3d.c. Neste novo programa, modifique o trecho da função main() que define o modo de apresentação no GLUT. Use a seguinte chamada para a função de inicialização: glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH), pois inclui o tratamento de profundidade e de superfícies escondidas no OpenGL . Além disso, ao invés de utilizar chamadas à função glutWireCube(), inclua chamadas apenas à função glutSolidCube(), que contém os mesmos argumentos. Acrescente à função init() as chamadas de função glEnable(GL_DEPTH_TEST); e glEnable(GL_CULL_FACE);, de modo que o tratamento de superfícies escondidas seja feito pelo OpenGL. Utilize cores diferentes para cada uma das partes do braço, de modo a obter um modelo semelhante ao da Figura 4.4. Possibilite também que a base do robô seja rotacionada em torno do eixo y, usando as teclas b e B, para girar nos sentidos horário e anti-horário.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="ex/4/Figura4.4.png" alt="Figura4.4">
</div>
</div>
<div class="ulist">
<div class="title">Arquivos:</div>
<ul>
<li>
<p><a href="ex/4/braco.c" target="_blank">braco-garra.c</a></p>
</li>
<li>
<p><a href="ex/4/braco-garra.c" target="_blank">braco-garra-3d.c</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_código_10">4.2.2. Código</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;

static int shoulder = 0, elbow = 0, thumb = 0, index = 0, middle = 0, base = 0;

void init(void){
  glClearColor (0.0, 0.0, 0.0, 0.0);
  //glEnable(GL_DEPTH_TEST); // Deveria ter essa linha, mas quando coloco quebra no meu laptop
  glEnable(GL_CULL_FACE);
}

void display(void){
  glClear (GL_COLOR_BUFFER_BIT);
  glPushMatrix();

  /* origem posicionada no ombro */
  glTranslatef (-1.0, 0.0, 0.0);
  glRotatef ((GLfloat) base, 0.0, 1.0, 0.0);
  glRotatef ((GLfloat) shoulder, 0.0, 0.0, 1.0);

  /* origem posicionada no centro do braco */
  glTranslatef (1.0, 0.0, 0.0);
  glPushMatrix();
  glScalef (2.0, 0.4, 1.0);
  glColor3f(1.0, 0.0, 0.0);
  glutSolidCube(1.0);
  glPopMatrix();

  /* origem posicionada no cotovelo */
  glTranslatef (1.0, 0.0, 0.0);
  glRotatef ((GLfloat) elbow, 0.0, 0.0, 1.0);
  glTranslatef (1.0, 0.0, 0.0);
  glPushMatrix();
  glScalef (2.0, 0.4, 1.0);
  glColor3f(0.0, 1.0, 0.0);
  glutSolidCube(1.0);
  glPopMatrix();

  /* origem posicionada no dedao */
	glTranslatef (1.0, 0.0, 0.0);
	glPushMatrix();
  glTranslatef (0.0, -0.2, 0.0);
  glRotatef ((GLfloat) thumb, 0.0, 0.0, 1.0);
  glTranslatef (0.25, 0.0, 0.0);
	glScalef (0.5, 0.1, 0.33);
  glColor3f(0.0, 0.0, 1.0);
  glutSolidCube(1.0);
  glPopMatrix();

  /* origem posicionada no indicador */
  glTranslatef (0.0, 0.2, 0.0);
	glPushMatrix();
	glTranslatef (0.0, 0.0, 0.33);
  glRotatef ((GLfloat) index, 0.0, 0.0, 1.0);
  glTranslatef (0.25, 0.0, 0.0);
	glScalef (0.5, 0.1, 0.33);
  glColor3f(1.0, 1.0, 0.0);
  glutSolidCube(1.0);
  glPopMatrix();

  /* origem posicionada no middle */
	glTranslatef (0.0, 0.0, -0.33);
  glRotatef ((GLfloat) middle, 0.0, 0.0, 1.0);
  glTranslatef (0.25, 0.0, 0.0);
	glScalef (0.5, 0.1, 0.33);
  glColor3f(1.0, 0.0, 1.0);
  glutSolidCube(1.0);
  glPopMatrix();

  /* origem volta para o sistema de coordenadas original */
  glPopMatrix();
  glutSwapBuffers();
}

void reshape (int w, int h){
  glViewport (0, 0, (GLsizei) w, (GLsizei) h);
  glMatrixMode (GL_PROJECTION);
  glLoadIdentity ();
  gluPerspective(65.0, (GLfloat) w/(GLfloat) h, 1.0, 20.0);
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  glTranslatef (0.0, 0.0, -10.0);
}

void keyboard (unsigned char key, int x, int y){
  switch (key) {
  case 's':
    shoulder = (shoulder + 5) % 360;
    glutPostRedisplay();
    break;
  case 'S':
    shoulder = (shoulder - 5) % 360;
    glutPostRedisplay();
    break;
  case 'e':
    elbow = (elbow + 5) % 360;
    glutPostRedisplay();
    break;
  case 'E':
    elbow = (elbow - 5) % 360;
    glutPostRedisplay();
    break;
  case 'p':
    thumb = (thumb + 5) % 360;
    glutPostRedisplay();
    break;
  case 'P':
    thumb = (thumb - 5) % 360;
    glutPostRedisplay();
    break;
  case 'i':
    index = (index + 5) % 360;
    glutPostRedisplay();
    break;
  case 'I':
    index = (index - 5) % 360;
    glutPostRedisplay();
    break;
  case 'm':
    middle = (middle + 5) % 360;
    glutPostRedisplay();
    break;
  case 'M':
    middle = (middle - 5) % 360;
    glutPostRedisplay();
    break;
  case 'b':
    base = (base + 5) % 360;
    glutPostRedisplay();
    break;
  case 'B':
    base = (base - 5) % 360;
    glutPostRedisplay();
    break;
  case 27:
    exit(0);
    break;
  default:
    break;
  }
}

int main(int argc, char** argv){
  glutInit(&amp;argc, argv);
  glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
  glutInitWindowSize (600, 600);
  glutInitWindowPosition (100, 100);
  glutCreateWindow (argv[0]);
  init ();
  glutDisplayFunc(display);
  glutReshapeFunc(reshape);
  glutKeyboardFunc(keyboard);
  glutMainLoop();
  return 0;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_imagem_10">4.2.3. Imagem</h4>
<div class="imageblock">
<div class="content">
<img src="ex/4/braco-garra-3d1.png" alt="braco garra 3d1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="ex/4/braco-garra-3d3.png" alt="braco garra 3d3">
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_projeções_geométricas">5. Projeções geométricas</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_tipos_de_projeções">5.1. Tipos de Projeções</h3>
<div class="sect3">
<h4 id="_questão_11">5.1.1. Questão</h4>
<div class="paragraph">
<p>Utilizando o programa projecoes.c como referência, implemente um programa tiposdeprojecoes.c. Este programa deverá conter mais sete opções de teclado: t e f, para exibir o topo e o fundo do objeto, F e T, para mostrar a frente e a face traseira, e e d, para mostrar a faces esquerda e direita, respectivamente, e a tecla c, para mostrar o triângulo do canto.</p>
</div>
<div class="ulist">
<div class="title">Arquivos:</div>
<ul>
<li>
<p><a href="ex/5/projecoes.c" target="_blank">projecoes.c</a></p>
</li>
<li>
<p><a href="ex/5/tiposdeprojecoes.c" target="_blank">tiposdeprojecoes.c</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_código_11">5.1.2. Código</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

void init(void);
void display(void);
void keyboard(unsigned char key, int x, int y);
void reshape (int w, int h);

#define AZUL     0.0, 0.0, 1.0
#define VERMELHO 1.0, 0.0, 0.0
#define AMARELO  1.0, 1.0, 0.0
#define VERDE    0.0, 1.0, 0.0
#define CYAN     1.0, 0.0, 1.0
#define LARANJA  0.8, 0.6, 0.1
#define ROSEO    0.7, 0.1, 0.6
#define CINZA    0.6, 0.6, 0.6

static GLfloat vertices[30]={
  0.0,  30.0, 30.0, /* 0 */
  20.0, 30.0, 30.0, /* 1 */
  30.0, 20.0, 30.0, /* 2 */
  30.0,  0.0, 30.0, /* 3 */
  0.0,   0.0, 30.0, /* 4 */
  0.0,  30.0,  0.0, /* 5 */
  30.0, 30.0,  0.0, /* 6 */
  30.0,  0.0,  0.0, /* 7 */
  0.0,   0.0,  0.0, /* 8 */
  30.0, 30.0, 20.0  /* 9 */
};

static GLubyte frenteIndices[]    = {0,4,3,2,1};
static GLubyte trasIndices[]      = {5,6,7,8};
static GLubyte esquerdaIndices[]  = {0,5,8,4};
static GLubyte direitaIndices[]   = {2,3,7,6,9};
static GLubyte topoIndices[]      = {0,1,9,6,5};
static GLubyte fundoIndices[]     = {3,4,8,7};
static GLubyte trianguloIndices[] = {1,2,9};

static int eixoy, eixox;
int largura, altura;

int main(int argc, char** argv){
  int i;
  glutInit(&amp;argc, argv);
  glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB);
  glutInitWindowSize (256, 256);
  glutInitWindowPosition (100, 100);
  glutCreateWindow (argv[0]);
  init();
  glutDisplayFunc(display);
  glutKeyboardFunc(keyboard);
  glutReshapeFunc(reshape);
  glutMainLoop();
  return 0;
}

void init(void){
  glClearColor(0.0, 0.0, 0.0, 0.0);
  glOrtho (-50, 50, -50, 50, -50 , 50);
  glEnable(GL_DEPTH_TEST);
  glEnable(GL_CULL_FACE);
}

void reshape (int w, int h){
  glViewport (0, 0, (GLsizei) w, (GLsizei) h);
  largura=w;
  altura=h;
}

void display(void){
  glPushMatrix();
  glRotatef ((GLfloat) eixoy, 0.0, 1.0, 0.0);
  glRotatef ((GLfloat) eixox, 1.0, 0.0, 0.0);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );

  glEnableClientState(GL_VERTEX_ARRAY);
  glVertexPointer(3, GL_FLOAT, 0, vertices);

  glColor3f (AZUL); /* frente */
  glDrawElements(GL_POLYGON, 5, GL_UNSIGNED_BYTE, frenteIndices);

  glColor3f (AMARELO); /* esquerda */
  glDrawElements(GL_POLYGON, 4, GL_UNSIGNED_BYTE, esquerdaIndices);

  glColor3f (VERMELHO); /* tras */
  glDrawElements(GL_POLYGON, 4, GL_UNSIGNED_BYTE, trasIndices);

  glColor3f (VERDE); /* direita */
  glDrawElements(GL_POLYGON, 5, GL_UNSIGNED_BYTE, direitaIndices);

  glColor3f (CYAN); /* topo */
  glDrawElements(GL_POLYGON, 5, GL_UNSIGNED_BYTE, topoIndices);

  glColor3f (LARANJA); /* fundo */
  glDrawElements(GL_QUADS, 4, GL_UNSIGNED_BYTE, fundoIndices);

  glColor3f (CINZA); /* triangulo */
  glDrawElements(GL_POLYGON, 3, GL_UNSIGNED_BYTE, trianguloIndices);

  glDisableClientState (GL_VERTEX_ARRAY);

  glPopMatrix();
  glutSwapBuffers();
}

void keyboard(unsigned char key, int x, int y){
  switch (key) {
  case 27:
    exit(0);
    break;
  case 'a':
    printf("%d, %d\n",x,y);
    break;
  case 'y':
    eixoy = (eixoy + 5) % 360;
    glutPostRedisplay();
    break;
  case 'Y':
    eixoy = (eixoy - 5) % 360;
    glutPostRedisplay();
    break;
  case 'x':
    eixox = (eixox + 5) % 360;
    glutPostRedisplay();
    break;
  case 'X':
    eixox = (eixox - 5) % 360;
    glutPostRedisplay();
    break;
  case 'p':
    glLoadIdentity();
    gluPerspective(65.0, (GLfloat) largura/(GLfloat) altura, 20.0, 120.0);
    gluLookAt(0, 0, -90, 0, 0, 0, 0, 1, 0);
    glutPostRedisplay();
    break;
  case 'o':
    glLoadIdentity();
    glOrtho (-50, 50, -50, 50, -50 , 50);
    glutPostRedisplay();
    break;
  case 't':
    eixox = 90;
    eixoy = 0;
    glutPostRedisplay();
    break;
  case 'f':
    eixox = 270;
    eixoy = 0;
    glutPostRedisplay();
    break;
  case 'T':
    eixox = 0;
    eixoy = 180;
    glutPostRedisplay();
    break;
  case 'F':
    eixox = 0;
    eixoy = 0;
    glutPostRedisplay();
    break;
  case 'd':
    eixox = 0;
    eixoy =270;
    glutPostRedisplay();
    break;
  case 'e':
    eixox = 0;
    eixoy = 90;
    glutPostRedisplay();
    break;
  case 'c':
    eixox = 45;
    eixoy = -45;
    glutPostRedisplay();
    break;
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_imagem_11">5.1.3. Imagem</h4>
<div class="imageblock">
<div class="content">
<img src="ex/5/tiposdeprojecoes1.png" alt="tiposdeprojecoes1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="ex/5/tiposdeprojecoes2.png" alt="tiposdeprojecoes2">
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_projeções_animadas">5.2. Projeções Animadas</h3>
<div class="paragraph">
<p>A função glutIdleFunc() é usada pelo GLUT para realizar operações em segundo plano ou animações, enquanto não recebe eventos de sistema. O seu protótipo é:</p>
</div>
<div class="paragraph">
<p>void glutIdleFunc(  *func);
void *func(void);</p>
</div>
<div class="paragraph">
<p>Tomando como base o programa projecoes.c, utilizando a função glutIdleFunc() e crie uma função de retorno idle(). Nesta função, os valores dos ângulos eixox e eixoy devem ser incrementados de valores constantes pequenos e diferentes, de modo a possibilitar uma animação. Utilize a função usleep() para introduzir retardos entre as apresentações dos quadros da animação, tornando mais agradável a visualização. Mantenhas as teclas o e p para chavear entre projeções ortogonais e de perspectiva.</p>
</div>
<div class="ulist">
<div class="title">Arquivos:</div>
<ul>
<li>
<p><a href="ex/5/projecoes.c" target="_blank">projecoes.c</a></p>
</li>
<li>
<p><a href="ex/5/projecoesAnimadas.c" target="_blank">projecoesAnimadas.c</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_código_12">5.2.1. Código</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

void init(void);
void display(void);
void keyboard(unsigned char key, int x, int y);
void reshape (int w, int h);
void idle(void);

#define AZUL     0.0, 0.0, 1.0
#define VERMELHO 1.0, 0.0, 0.0
#define AMARELO  1.0, 1.0, 0.0
#define VERDE    0.0, 1.0, 0.0
#define CYAN     1.0, 0.0, 1.0
#define LARANJA  0.8, 0.6, 0.1
#define ROSEO    0.7, 0.1, 0.6
#define CINZA    0.6, 0.6, 0.6

static GLfloat vertices[30]={
  0.0,  30.0, 30.0, /* 0 */
  20.0, 30.0, 30.0, /* 1 */
  30.0, 20.0, 30.0, /* 2 */
  30.0,  0.0, 30.0, /* 3 */
  0.0,   0.0, 30.0, /* 4 */
  0.0,  30.0,  0.0, /* 5 */
  30.0, 30.0,  0.0, /* 6 */
  30.0,  0.0,  0.0, /* 7 */
  0.0,   0.0,  0.0, /* 8 */
  30.0, 30.0, 20.0  /* 9 */
};

static GLubyte frenteIndices[]    = {0,4,3,2,1};
static GLubyte trasIndices[]      = {5,6,7,8};
static GLubyte esquerdaIndices[]  = {0,5,8,4};
static GLubyte direitaIndices[]   = {2,3,7,6,9};
static GLubyte topoIndices[]      = {0,1,9,6,5};
static GLubyte fundoIndices[]     = {3,4,8,7};
static GLubyte trianguloIndices[] = {1,2,9};

static int eixoy, eixox;
int largura, altura;

int main(int argc, char** argv){
  int i;
  glutInit(&amp;argc, argv);
  glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB);
  glutInitWindowSize (256, 256);
  glutInitWindowPosition (100, 100);
  glutCreateWindow (argv[0]);
  init();
  glutDisplayFunc(display);
  glutKeyboardFunc(keyboard);
  glutReshapeFunc(reshape);
  glutMainLoop();
  return 0;
}

void init(void){
  glClearColor(0.0, 0.0, 0.0, 0.0);
  glOrtho (-50, 50, -50, 50, -50 , 50);
  glEnable(GL_DEPTH_TEST);
  glEnable(GL_CULL_FACE);
}

void reshape (int w, int h){
  glViewport (0, 0, (GLsizei) w, (GLsizei) h);
  largura=w;
  altura=h;
}

void display(void){
  glPushMatrix();
  glRotatef ((GLfloat) eixoy, 0.0, 1.0, 0.0);
  glRotatef ((GLfloat) eixox, 1.0, 0.0, 0.0);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );

  glEnableClientState(GL_VERTEX_ARRAY);
  glVertexPointer(3, GL_FLOAT, 0, vertices);

  glColor3f (AZUL); /* frente */
  glDrawElements(GL_POLYGON, 5, GL_UNSIGNED_BYTE, frenteIndices);

  glColor3f (AMARELO); /* esquerda */
  glDrawElements(GL_POLYGON, 4, GL_UNSIGNED_BYTE, esquerdaIndices);

  glColor3f (VERMELHO); /* tras */
  glDrawElements(GL_POLYGON, 4, GL_UNSIGNED_BYTE, trasIndices);

  glColor3f (VERDE); /* direita */
  glDrawElements(GL_POLYGON, 5, GL_UNSIGNED_BYTE, direitaIndices);

  glColor3f (CYAN); /* topo */
  glDrawElements(GL_POLYGON, 5, GL_UNSIGNED_BYTE, topoIndices);

  glColor3f (LARANJA); /* fundo */
  glDrawElements(GL_QUADS, 4, GL_UNSIGNED_BYTE, fundoIndices);

  glColor3f (CINZA); /* triangulo */
  glDrawElements(GL_POLYGON, 3, GL_UNSIGNED_BYTE, trianguloIndices);

  glDisableClientState (GL_VERTEX_ARRAY);

  glPopMatrix();

  glutSwapBuffers();

  glutIdleFunc(idle);
}

void keyboard(unsigned char key, int x, int y){
  switch (key) {
  case 27:
    exit(0);
    break;
  case 'a':
    printf("%d, %d\n",x,y);
    break;
  case 'p':
    glLoadIdentity();
    gluPerspective(65.0, (GLfloat) largura/(GLfloat) altura, 20.0, 120.0);
    gluLookAt(0, 0, -90, 0, 0, 0, 0, 1, 0);
    glutPostRedisplay();
    break;
  case 'o':
    glLoadIdentity();
    glOrtho (-50, 50, -50, 50, -50 , 50);
    glutPostRedisplay();
    break;
  }
}
void idle(void) {

  eixox = (eixox + 1) % 360;
  eixoy = (eixoy + 1) % 360;
  glutPostRedisplay();
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_imagem_12">5.2.2. Imagem</h4>
<div class="imageblock">
<div class="content">
<img src="ex/5/projecoesAnimadas1.png" alt="projecoesAnimadas1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="ex/5/projecoesAnimadas2.png" alt="projecoesAnimadas2">
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2015-09-14 15:27:20 BRT
</div>
</div>
</body>
</html>